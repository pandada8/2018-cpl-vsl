# This is a shell archive.  Remove anything before this line, then
# unpack it by saving it in a file and typing "sh file".  (Files
# unpacked will be owned by you and have default permissions.)
#
# This archive contains:
# Makefile-vc
# cg.c
# header
# lib
# main.c
# optimize.c
# parser.y
# scanner.l
# vc.h

echo x - Makefile-vc
mv Makefile-vc Makefile-vc.old
cat > "Makefile-vc" << '//E*O*F Makefile-vc//'
#
# A Makefile for the simple VSL compiler
#

# How to compile with cc

.c.o:
	cc -c $(CFLAGS) $*.c

# Flags

CFLAGS = -g -ansi -pedantic

# The files involved

HDRS = vc.h

CSRCS = main.c \
        cg.c \
        optimize.c

SRCS = $(CSRCS) \
       scanner.c \
       parser.c

OBJS = main.o \
       parser.o \
       scanner.o \
       cg.o \
       optimize.o

# Create a new compiler

vc: $(OBJS)
	cc $(CFLAGS) $(OBJS) -ll -o ../bin/vc

# C dependencies

$(OBJS): $(HDRS)

main.o: parser.h

# Dependencies of LEX and YACC files

scanner.c: scanner.l
	lex scanner.l
	mv lex.yy.c scanner.c

scanner.o: scanner.c parser.h

parser.c parser.h: parser.y
	yacc -d parser.y
	mv y.tab.c parser.c
	mv y.tab.h parser.h


# Print out the source files

print:
	enscript -2rh $(HDRS) scanner.l parser.y $(CSRCS)

# Profile option to see what's happening

profile:
	cc -p $(SRCS) -ll -o profile-vc
//E*O*F Makefile-vc//

echo x - cg.c
mv cg.c cg.c.old
cat > "cg.c" << '//E*O*F cg.c//'
/******************************************************************************
*******************************************************************************


                                CCCCC    GGGGGG 
                               CCCCCCC  GGGGGGGG
                              CC        GG      
                              CC        GG  GGGG
                              CC        GG    GG
                              CC        GG    GG
                               CCCCCCC  GGGGGGGG
                                CCCCC    GGGGGG 


*******************************************************************************
*******************************************************************************

			      A Compiler for VSL
			      ==================

   This is the code generator section

   Modifications:
   ==============

   22 Nov 88 JPB:  First version
   26 Apr 89 JPB:  Version for publication
    1 Aug 89 JPB:  Final version for publication
   13 Jun 90 JPB:  Now refers to library directory (noted by R C Shaw, Praxis).

*******************************************************************************
******************************************************************************/


#include <stdio.h>
#include <ctype.h>
#include "vc.h"

/* Constants used here. First we define some of the registers. We reserve
   register R1 as the stack pointer and use registers R2 - R4 in the calling
   and return sequences. */

#define R_ZERO          0		 /* Constant zero */
#define R_P             1		 /* Stack pointer */
#define R_CALL          2		 /* Address of called routine */
#define R_RET           3		 /* Return address */
#define R_RES           4		 /* Result reg and last reserved */
#define R_GEN           5		 /* First general purpose register */
#define R_MAX          16		 /* 16 regs */

/* The stack frame holds the dynamic link at offset zero and the return address
   at offset 4. */

#define P_OFF           0                /* Offset of stack pointer on frame */
#define PC_OFF          4                /* Offset of ret address on frame */
#define VAR_OFF         8                /* Offset of variables on frame */

/* To make the code clearer we define flags MODIFIED and UNMODIFIED as TRUE and
   FALSE respectively for setting the mod field of the register descriptor. */

#define MODIFIED     TRUE		 /* Entries for descriptors */
#define UNMODIFIED  FALSE

/* These are static variables used throughout this section. The register
   descriptor is an array of anonymous structures with a field to hold the most
   recent item slaved in the register and a field to mark whether the register
   has been modified since last written to memory.

   "tos" is the top of stack in the current function and "next_arg" is the
   number of the next argument to load on the stack. */

struct			 		 /* Reg descriptor */
{
	struct symb *name ;		 /* Thing in reg */
	int          modified ;		 /* If needs spilling */
}    rdesc[R_MAX] ;
int  tos ;				 /* Top of stack */
int  next_arg ;				 /* Next argument to load */

/* These are the prototypes of routines defined here. Routines to translate TAC
   instructions generally have the form "cg_xxx()" where xxx is the name of a
   TAC instruction of group of TAC instructions. */

void  cg( TAC *tl ) ;
TAC  *init_cg( TAC *tl ) ;
void  cg_instr( TAC *c ) ;
void  cg_bin( char *op,
	      SYMB *a,
	      SYMB *b,
	      SYMB *c ) ;
void  cg_copy( SYMB *a,
	       SYMB *b ) ;
void  cg_cond( char *op,
	       SYMB *a,
	       int   l ) ;
void  cg_arg( SYMB *a ) ;
void  cg_call( int   f,
	       SYMB *res ) ;
void  cg_return( SYMB *a ) ;
void  cg_sys( char *fn ) ;
void  cg_strings( void ) ;
void  cg_str( SYMB *s ) ;
void  flush_all( void ) ;
void  spill_all( void ) ;
void  spill_one( int  r ) ;
void  load_reg( int   r,
		SYMB *n ) ;
void  clear_desc( int   r ) ;
void  insert_desc( int   r,
		   SYMB *n,
		   int   mod ) ;
int   get_rreg( SYMB *c ) ;
int   get_areg( SYMB *b,
	       int   cr ) ;


void  cg( TAC *tl )

/* The code generator is initialised by "cg_init()", finding the start of the
   TAC list in the process (since the syntax analysis phase has given us the
   end of the list, and the code generator works from the start of the list).

   We first copy a header file to the output containing initialisation code and
   then loop generating code for each TAC instruction. The code is preceded by
   a comment line in the assembler giving the TAC instruction being translated.
   After generating code for the TAC, we copy the library file and then
   generate code for all the text strings used in the program.

   Note that in the book the header and lib files are just referred to as
   "header" and "lib", thus assuming that they will be in the same directory
   that the compiler is run in. We have included a #defined library path here
   for greater flexibility. */

{
	TAC *tls = init_cg( tl ) ;              /* Start of TAC */

        if( optiflag )
          optimize( tls ) ;                     /* Do the optimization */

	cg_sys( LIB_DIR "header" ) ;		 /* Standard header */

	for( ; tls != NULL ; tls = tls->next )  /* Instructions in turn */
	{
		printf( "\\ " ) ;
		print_instr( tls ) ;
		cg_instr( tls ) ;
	}

	cg_sys( LIB_DIR "lib" ) ;		 /* Library */
	cg_strings() ;				 /* String data */

}	/* void  cg( TAC *tl ) */


TAC *init_cg( TAC *tl )

/* Initialisation involves clearing the register descriptors (apart from zero
   in R0), setting the top of stack and next_arg indices and clearing the free
   lists for address and register descriptors. We finally find the end of the
   TAC list, setting .cb next fields in the TAC as we do so. */

{
	int  r ;
        TAC *c ;			 /* Current TAC instruction */
	TAC *p ;			 /* Previous TAC instruction */

	for( r = 0 ; r < R_MAX ; r++ )
		rdesc[r].name = NULL ;

	insert_desc( 0, mkconst( 0 ), UNMODIFIED ) ;	 /* R0 holds 0 */

	tos      = VAR_OFF ; 		 /* TOS allows space for link info */
	next_arg = 0 ;			 /* Next arg to load */

	/* Tidy up and reverse the code list */

	c = NULL ;			 /* No current */
	p = tl ;			 /* Preceding to do */

	while( p != NULL )
	{
		p->next = c ;		 /* Set the next field */
		c       = p ;		 /* Step on */
		p       = p->prev ;
	}

	return c ;

}	/* TAC *init_cg( TAC *tl ) */


void  cg_instr( TAC *c )

/* Generate code for a single TAC instruction. This is just a switch on all
   possible TAC instructions. Hopefully if we have written the front end
   correctly the default case will never be encountered. For most cases we just
   call a subsidiary routine "cg_xxx()" to do the code generation. */

{
	switch( c->op )
	{
	case TAC_UNDEF:

		error( "cannot translate TAC_UNDEF" ) ;
		return ;

	case TAC_ADD:

		cg_bin( "ADD", c->VA, c->VB, c->VC ) ;
		return ;

	case TAC_SUB:

		cg_bin( "SUB", c->VA, c->VB, c->VC ) ;
		return ;

	case TAC_MUL:

		cg_bin( "MUL", c->VA, c->VB, c->VC ) ;
		return ;

	case TAC_DIV:

		cg_bin( "DIV", c->VA, c->VB, c->VC ) ;
		return ;

	case TAC_NEG:

		cg_bin( "SUB", c->VA, mkconst( 0 ), c->VB ) ;
		return ;

	case TAC_COPY:

		cg_copy( c->VA, c->VB ) ;
		return ;

	case TAC_GOTO:

		cg_cond( "BRA", NULL, c->LA->VA->VAL1 ) ;
		return ;

	case TAC_IFZ:

		cg_cond( "BZE", c->VB, c->LA->VA->VAL1 ) ;
		return ;

	case TAC_IFNZ:

		cg_cond( "BNZ", c->VB, c->LA->VA->VAL1 ) ;
		return ;

	case TAC_ARG:

		cg_arg( c->VA ) ;
		return ;

	case TAC_CALL:

		cg_call( c->LB->VA->VAL1, c->VA ) ;
		return ;

	case TAC_RETURN:

		cg_return( c->VA ) ;
		return ;

	case TAC_LABEL:

		/* We generate an appropriate label. Note that we must flush
 		   the register descriptor, since control may arrive at this
		   label from other points in the code. */

		flush_all() ;
		printf( "L%d:\n", c->VA->VAL1 ) ;
		return ;

	case TAC_VAR:

		/* Allocate 4 bytes for this variable to hold an integer on the
		   current top of stack */

		c->VA->ADDR2 = tos ;
		tos += 4 ;
		return ;

	case TAC_BEGINFUNC:

		/* At the start of a function we must copy the return address
		   which will be in R_RET onto the stack. We reset the top of
		   stack, since it is currently empty apart from the link
		   information. */

		tos = VAR_OFF ;
		printf( "       STI  R%d,%d(R%d)\n", R_RET, PC_OFF, R_P ) ;
		return ;

	case TAC_ENDFUNC:

		/* At the end of the function we put in an implicit return
		   instruction. */

		cg_return( NULL ) ;
		return ;

	default:

		/* Don't know what this one is */

		error( "unknown TAC opcode to translate" ) ;
		return ;
	}

}	/* void  cg_instr( TAC *c ) */


void  cg_bin( char *op,			 /* Opcode to use */
	      SYMB *a,			 /* Result */
	      SYMB *b,			 /* Operands */
	      SYMB *c )

/* Generate code for a binary operator

      a := b op c

   VAM has 2 address opcodes with the result going into the second operand

   This is a typical code generation functions. We find and load a separate
   register for each argument, the second argument also being used for the
   result. We then generate the code for binary operator, updating the register
   descriptor appropriately. */

{
	int  cr = get_rreg( c ) ;	 /* Result register */
	int  br = get_areg( b, cr ) ;	 /* Second argument register */

	printf( "       %s  R%d,R%d\n", op, br, cr ) ;

	/* Delete c from the descriptors and insert a */

	clear_desc( cr ) ;
	insert_desc( cr, a, MODIFIED ) ;

}	/* void  cg_bin( char *op,
	  	         SYMB *a,
	      		 SYMB *b,
	      		 SYMB *c ) */


void  cg_copy( SYMB *a,
	       SYMB *b )

/* Generate code for a copy instruction

      a := b

   We load b into an register, then update the descriptors to indicate that a
   is also in that register. We need not do the store until the register is
   spilled or flushed. */

{
	int  br = get_rreg( b ) ;   	 /* Load b into a register */

	insert_desc( br, a, MODIFIED ) ; /* Indicate a is there */

}	/* void  cg_copy( SYMB *a,
		       	  SYMB *b ) */


void  cg_cond( char *op,
	       SYMB *a,			 /* Condition */
	       int   l )		 /* Branch destination */

/* Generate for "goto", "ifz" or "ifnz". We must spill registers before the
   branch. In the case of unconditional goto we have no condition, and so "b"
   is NULL. We set the condition flags if necessary by explicitly loading "a"
   into a register to ensure the zero flag is set. A better approach would be
   to keep track of what is in the status register, so saving this load. */

{
	spill_all() ;

	if( a != NULL )
	{
		int  r ;

		for( r = R_GEN ; r < R_MAX ; r++ )   /* Is it in reg? */
			if( rdesc[r].name == a )
				break ;

		if( r < R_MAX )

                        /* Reload into existing reg */
                        /* Don't use load_reg since it updates rdesc */

                        printf( "       LDR  R%d,R%d\n", r, r ) ;
		else
			(void)get_rreg( a ) ;  /* Load into new register */
	}

	printf( "       %s  L%d\n", op, l ) ;   /* Branch */

}	/* void  cg_cond( char *op,
	     	          SYMB *a,
	     		  int   l ) */


void  cg_arg( SYMB *a )

/* Generate for an ARG instruction. We load the argument into a register, and
   then write it onto the new stack frame, which is 2 past the current top of
   stack. We keep track of which arg this is in the global variable "next_arg".
   We assume that ARG instructions are always followed by other ARG
   instructions or CALL instructions. */

{
	int  r  = get_rreg( a ) ;

	printf( "       STI  R%d,%d(R%d)\n", r, tos + VAR_OFF + next_arg,
		R_P ) ;
	next_arg += 4 ;

}	/* void  cg_arg( SYMB *a ) */


void  cg_call( int   f,
	       SYMB *res )

/* The standard call sequence is

      LDA  f(R0),R2
      STI  R1,tos(R1)
      LDA  tos(R1),R1
      BAL  R2,R3
    ( STI  R4,res )

   We flush out the registers prior to a call and then execute the standard
   CALL sequence. Flushing involves spilling modified registers, and then
   clearing the register descriptors. We use BAL to do the call, which means
   R_RET will hold the return address on entry to the function which must be
   saved on the stack. After the call if there is a result it will be in R_RES
   so enter this in the descriptors.  We reset "next_arg" before the call,
   since we know we have finished all the arguments now. */

{
	flush_all() ;
	next_arg = 0 ;
	printf( "       LDA  L%d,R%d\n", f, R_CALL ) ;
	printf( "       STI  R%d,%d(R%d)\n", R_P, tos, R_P ) ;
	printf( "       LDA  %d(R%d),R%d\n", tos, R_P, R_P ) ;
	printf( "       BAL  R%d,R%d\n", R_CALL, R_RET ) ;

	if( res != NULL )		      /* Do a result if there is one */
		insert_desc( R_RES, res, MODIFIED ) ;

}	/* void  cg_call( int   f,
		          SYMB *res ) */


void  cg_return( SYMB *a )

/* The standard return sequence is

    ( LDI  a,R4 )
      LDI  4(R1),R2    return program counter
      LDI  0(R1),R1    return stack pointer
      BAL  R2,R3

   If "a" is NULL we don't load anything into the result register.
*/

{
	if( a != NULL )
	{
		spill_one( R_RES ) ;
		load_reg( R_RES, a ) ;
	}

	printf( "       LDI  %d(R%d),R%d\n", PC_OFF, R_P, R_CALL ) ;	
	printf( "       LDI  %d(R%d),R%d\n", P_OFF, R_P, R_P ) ;	
	printf( "       BAL  R%d,R%d\n", R_CALL, R_RET ) ;	

}	/* void  cg_return( SYMB *a ) */


void  cg_sys( char *fn )		 /* File name */

/* This routine is used to copy standard header and library files into the
   generated code. */

{
	FILE *fd = fopen( fn, "r" ) ; /* The library file */
	int  c ;

	if( fd == NULL )
	{
		error( "cannot open system file" ) ;
		exit( 0 ) ;
	}

	while((c = getc( fd )) != EOF )
		putchar( c ) ;

	fclose( fd ) ;

}	/* void  cg_sys( char *fn ) */


void  cg_strings( void )

/* This routine runs through the symbol table at the end of code generation to
   find all the strings, calling "cg_str()" to generate each string as a series
   of bytes declarations. It finally generates label zero to mark the end of
   code. */

{
	int  i ;

	for( i = 0 ; i < HASHSIZE ; i++)   /* Find all symbol table chains */
	{
		SYMB *sl ;

		for( sl = symbtab[i] ; sl != NULL ; sl = sl->next )
			if( sl->type == T_TEXT )
				cg_str( sl ) ;
	}

	printf( "L0:\n" ) ;

}	/* void  cg_strings( void ) */


void  cg_str( SYMB *s )

/* Generate bytes for this string. Ignore the quotes and translate escapes */

{
	char *t = s->TEXT1 ;		 /* The text */
	int   i ;

	printf( "L%d:\n", s->VAL2 ) ;	 /* Label for the string */

	for( i = 1 ; t[i + 1] != EOS ; i++ )
		if( t[i] == '\\' )
			switch( t[++i] )
			{
				case 'n':

					printf( "       DB   %d\n", '\n' ) ;
					break ;

				case '\"':

					printf( "       DB   %d\n", '\"' ) ;
					break ;
			}
		else
			printf( "       DB   %d\n", t[i] ) ;

	printf( "       DB   0\n" ) ;	 /* End of string */

}	/* void  cg_str( SYMB *s ) */


/* These are the support routines for the code generation. "flush_all()' is
   used to write all modified registers and clear the registers at points where
   their validity can not be guaranteed (after labels and function calls).
   "spill_all()" is used to write all modified registers at points where we
   wish memory to be consistent (prior to a branch).  "spill_one()" is used to
   write a specific register out if it is modified. */


void  flush_all( void )

/* Spill all registers, and clear their descriptors */

{
	int  r ;

	spill_all() ;

	for( r = R_GEN ; r < R_MAX ; r++ )   /* Clear the descriptors */
		clear_desc( r ) ;

}	/* void  flush_all( void ) */


void  spill_all( void )

/* Spill all the registers */

{
	int  r ;

	for( r = R_GEN ; r < R_MAX ; r++ )
		spill_one( r ) ;

}	/* spill_all( void ) */


void  spill_one( int  r )

/* Spill the value in register r if it's modifed */

{
	if( rdesc[r].modified )
	{
		printf( "       STI  R%d,%d(R%d)\n", r, rdesc[r].name->ADDR2,
			R_P ) ;
		rdesc[r].modified = UNMODIFIED ;
	}

}	/* void  spill_one( int  r ) */


void  load_reg( int   r,		 /* Register to be loaded */
		SYMB *n )		 /* Name to load */

/* "load_reg()" loads a value into a register. If the value is in a different
   register it uses LDR. If it is a constant it uses LDA indexed off R0 and if
   a piece of text, the address of the text is loaded with LDA. Variables are
   loaded from the stack with LDI.

   We update the register descriptor accordingly */

{
	int  s ;

	/* Look for a register */

	for( s = 0 ; s < R_MAX ; s++ )	
		if( rdesc[s].name == n )
		{
			printf( "       LDR  R%d,R%d\n", s, r ) ;
			insert_desc( r, n, rdesc[s].modified ) ;
			return ;
		}

	/* Not in a reg. Load appropriately */

	switch( n->type )
	{
	case T_INT:

		printf( "       LDA  %d(R0),R%d\n", n->VAL1, r ) ;
		break ;

	case T_VAR:

		printf( "       LDI  %d(R%d),R%d\n", n->ADDR2, R_P, r ) ;
		break ;

	case T_TEXT:

		printf( "       LDA  L%d,R%d\n", n->VAL2, r ) ;
		break ;
	}

	insert_desc( r, n, UNMODIFIED ) ;

}	/* void  load_reg( int   r,
			   SYMB *n ) */


/* We have two routines to handle the register descriptor. "clear_desc()"
   removes any slave information in a register, "insert_desc()" inserts slave
   information. */


void  clear_desc( int   r )		 /* Register to delete */

/* Clear the descriptor for register r */

{
	rdesc[r].name = NULL ;

}	/* void  clear_desc( int   r ) */


void  insert_desc( int   r,
		   SYMB *n,
		   int   mod )

/* Insert a descriptor entry for the given name. */

{
	rdesc[r].name     = n ;
	rdesc[r].modified = mod ;

}	/* void  insert_desc( int   r,
		   	      SYMB *n,
		   	      int   mod ) */


/* These two routines implement the simple register allocation algorithm
   described in chapter 10. "get_rreg()" gets a register that will hold an
   operand and be overwritten by a result. "get_areg()" gets a register that
   will hold an operand that will no be overwritten. */


int  get_rreg( SYMB *c )

/* Get a register to hold the result of the computation

      a := b op c

   This must initially hold c and will be overwritten with a. If c is already
   in a register we use that, spilling it first if necessary, otherwise we
   chose in order of preference from

      An empty register
      An unmodified register
      A modified register

   In the last case we spill the contents of the register before it is used. If
   c is not in the given result register we load it. Clearly we cannot use R0
   for this purpose, even if c is constant zero. We also avoid using the
   reserved registers. Note that since c may be the same as b we must update
   the address and register descriptors. */ 

{
	int        r ;			 /* Register for counting */

	for( r = R_GEN ; r < R_MAX ; r++ )   /* Already in a register */
		if( rdesc[r].name == c )
		{
			spill_one( r ) ;
			return r ;
		}

	for( r = R_GEN ; r < R_MAX ; r++ )
		if( rdesc[r].name == NULL )  /* Empty register */
		{
			load_reg( r, c ) ;
			return r ;
		}

	for( r = R_GEN ; r < R_MAX ; r++ )
		if( !rdesc[r].modified )     /* Unmodifed register */
		{
			clear_desc( r ) ;
			load_reg( r, c ) ;
			return r ;
		}

	spill_one( R_GEN ) ;		     /* Modified register */
	clear_desc( R_GEN ) ;
	load_reg( R_GEN, c ) ;
	return R_GEN ;

}	/* int  get_rreg( SYMB *c ) */


int  get_areg( SYMB *b,
	       int   cr )		 /* Register already holding b */

/* Get a register to hold the second argument of the computation

      a := b op c

   This must hold b and will not be overwritten. If b is already in a register
   we use that, otherwise we chose in order of preference from 

      An empty register
      An unmodified register
      A modified register

   In the last case we spill the contents of the register before it is used. If
   b is not in the given argument register we load it. We can use R0 for this
   purpose, even if b is constant zero, but we avoid using the reserved
   registers. We may not use cr unless it already contains b. */

{
	int        r ;			 /* Register for counting */

	for( r = R_ZERO ; r < R_MAX ; r++ )
		if( rdesc[r].name == b )              /* Already in register */
			return r ;

	for( r = R_GEN ; r < R_MAX ; r++ )
		if( rdesc[r].name == NULL )           /* Empty register */
		{
			load_reg( r, b ) ;
			return r ;
		}

	for( r = R_GEN ; r < R_MAX ; r++ )
		if( !rdesc[r].modified && (r != cr))  /* Unmodifed register */
		{
			clear_desc( r ) ;
			load_reg( r, b ) ;
			return r ;
		}

	for( r = R_GEN ; r < R_MAX ; r++ )
		if( r != cr )		 	       /* Modified register */
		{
			spill_one( r ) ;
			clear_desc( r ) ;
			load_reg( r, b ) ;
			return r ;
		}

}	/* int  get_areg( SYMB *b,
	  	          int   cr ) */
//E*O*F cg.c//

echo x - header
mv header header.old
cat > "header" << '//E*O*F header//'
       LDA  L0,R1
       STI  R1,0(R1)
       LDA  L1,R3
//E*O*F header//

echo x - lib
mv lib lib.old
cat > "lib" << '//E*O*F lib//'
L1:
       HALT
L2:
       STI  R3,4(R1)
       LDI  8(R1),R15
       LDA  10(R0),R5
       DIV  R15,R5
       BZE  L3
       STI  R5,12(R1)
       STI  R5,24(R1)
       LDA  L2,R2
       STI  R1,16(R1)
       LDA  16(R1),R1
       BAL  R2,R3
       LDA  10(R0),R15
       LDI  8(R1),R5
       LDI  12(R1),R6
       MUL  R6,R15
       SUB  R5,R15
L3:
       LDA  48(R0),R5
       ADD  R5,R15
       TRAP
       LDI  4(R1),R2
       LDI  0(R1),R1
       BAL  R2,R3
L4:
       STI  R3,4(R1)
       LDI  8(R1),R5
       LDA  16777216(R0),R7
L5:
       LDI  0(R5),R6
       LDR  R7,R15
       DIV  R6,R15
       BZE  L6
       TRAP
       LDA  1(R5),R5
       BRA  L5
L6:
       LDI  4(R1),R2
       LDI  0(R1),R1
       BAL  R2,R3
//E*O*F lib//

echo x - main.c
mv main.c main.c.old
cat > "main.c" << '//E*O*F main.c//'
/******************************************************************************
*******************************************************************************


                    MM    MM    AAAA    IIIIIIII  NN    NN
                    MMM  MMM   AAAAAA   IIIIIIII  NNN   NN
                    MMMMMMMM  AA    AA     II     NNNN  NN
                    MM MM MM  AAAAAAAA     II     NN NN NN
                    MM    MM  AA    AA     II     NN  NNNN
                    MM    MM  AA    AA     II     NN  NNNN
                    MM    MM  AA    AA  IIIIIIII  NN   NNN
                    MM    MM  AA    AA  IIIIIIII  NN    NN


*******************************************************************************
*******************************************************************************

			      A Compiler for VSL
			      ==================

   These are the main, initialisation, tidy up and utility routines.

   Modifications:
   ==============

   22 Nov 88 JPB:  First version
   26 Apr 89 JPB:  Version for publication
   13 Jun 90 JPB:  mklabel fixed to return t

*******************************************************************************
******************************************************************************/

/* As well as including the general header we include the header "parser.h"
   generated by YACC, which contains definitions of all the terminals. Note
   that this is the file "y.tab.h" obtained by running yacc with the -d option.
   We rename it "parser.h" when building the compiler for clarity. */

#include <stdio.h>
#include <ctype.h>
#include "vc.h"
#include "parser.h"

/* Constants used here. CONST_MAX gives the number of small integers
   pre-intialised in the symbol table (described later). LAB_MIN is the first
   label number to be used. Label L0 is reserved for the end of code and data
   and L1 for the termination routine. Labels up to LAB_MIN - 1 may be used by
   the library routines. */

#define CONST_MAX  5
#define LAB_MIN   10

/* We also declare as external the text array and associated variables,
   "yytext" , "yyleng" and "yylval" defined in the parser and scanner which we
   will need to refer to in this section. */

extern char    yytext[] ;
extern int     yyleng ;
extern YYSTYPE yyval ;

/* We define a number of static variables used throughout the compiler. These
   have been declared external in the header file, and are defined here. */

SYMB  *symbtab[HASHSIZE] ;		 /* Symbol table */
TAC   *library[LIB_MAX] ;		 /* Entries for library routines */
int    next_tmp ;			 /* Count of temporaries */
int    next_label ;			 /* Count of labels */
char   optiflag, filename[50] ;          /* Optimizer information */

/* These are static variables used throughout this section. "const_tab" is the
   table of predeclared integers. "errors_found" is a flag set if the error
   routine is ever called. We do not bother to generate code if errors are
   found during parsing.

   Symbol table and expression nodes are regularly allocated, freed and
   reallocated. Rather than use the system routines "malloc()" and "free()"
   directly for this, we maintain our own freelists, held in "symb_list" and
   "enode_list". */

SYMB  *const_tab[CONST_MAX] ;		 /* Small constants */
int    errors_found ;			 /* True if we have any errors */
SYMB  *symb_list ;			 /* Freelists */
ENODE *enode_list ;

/* Prototypes of routines defined in this section. */

void   main( int argc, char **argv ) ;
void   init_vc( int argc, char **argv ) ;
SYMB  *mkconst( int  n ) ;
SYMB  *mklabel( int  l ) ;
SYMB  *mktmp( void ) ;
SYMB  *get_symb( void ) ;
void   free_symb( SYMB *s ) ;
ENODE *get_enode( void ) ;
void   free_enode( ENODE *e ) ;
void  *safe_malloc( int  n ) ;
TAC   *mktac( int   op,
	      SYMB *a,
	      SYMB *b,
	      SYMB *c ) ;
TAC   *join_tac( TAC *c1,
	         TAC *c2 ) ;
void   insert( SYMB *s ) ;
int    hash( char *s ) ;
SYMB  *lookup( char *s ) ;
void   print_instr( TAC *i ) ;
char  *ts( SYMB *s,
	   char *str ) ;
void   error( char *str ) ;


void  main( int argc, char **argv )

/* The main program initialises the compiler, calls the syntax analyser and if
   this runs successfuly passes the resulting TAC on for code generation. */

{
	init_vc( argc, argv ) ;		 /* Set up things */

	(void) yyparse() ;		 /* Parse */

	if( !errors_found )
		cg( yyval.tac ) ;	 /* Generate code from TAC */

}	/* void  main( int argc, char **argv ) */


void  init_vc( int argc, char **argv )

/* Initialisation involves setting various system wide variables to sensible
   values and clearing down the symbol table. Small constants are so common we
   put them in the symbol table first and record their addresses in a table. We
   do this for the integers 0 to COUNT_MAX - 1. This will permit us efficient
   access to them throughout the compiler.

   We record the entry labels for the library routines. We happen to know from
   inspection of the library code that the entry point to PRINTN is L2 and to
   PRINTS is L4. If we rewrite the library then we may have to change these.
   This is really rather clumsy, and at the very least ought to be put in a
   single table somewhere. Note that earlier we set the first label to be used
   to L10, permitting the use of labels up to L9 for library use. */

{
	int  i ;			     /* General counter */

	symb_list   = NULL ;		     /* Freelists */
	enode_list  = NULL ;

	errors_found = FALSE ;		     /* No errors found yet */
	next_tmp     = 0 ;		     /* No temporaries used */
	next_label   = LAB_MIN ;	     /* 10 labels reserved */

	for( i = 0 ; i < HASHSIZE ; i++ )    /* Clear symbol table */
		symbtab[i] = NULL ;

	for( i = 0 ; i < CONST_MAX ; i++ )   /* Make constants */
	{
		SYMB *c = get_symb() ;	     /* Node for the constant */

		c->type      = T_INT ;
		c->VAL1      = i ;
		const_tab[i] = c ;
	}

	library[LIB_PRINTN] = mktac( TAC_LABEL, mklabel( 2 ), NULL, NULL ) ;
	library[LIB_PRINTS] = mktac( TAC_LABEL, mklabel( 4 ), NULL, NULL ) ;

        if( argc > 1 )
        {
                if( strcmp( argv[1], "-O" ) == 0 )
                {
                        optiflag = TRUE;
                        if( argc > 2 )
                                strcpy( filename, argv[2] );
                        else
                                *filename = 0;
                }
                else
                        error( "invalid argument" );
        }
        else
        {
                optiflag = FALSE;
                *filename = 0;
        }

}     /* void  init_vc( int argc, char **argv ) */


/* We now have a number of routines to set up symbol table nodes of various
   types. Memory allocation usually involves up to three routines, "mkxxx()" to
   allocate and set up the fields of a struct of type "xxx", "get_xxx()" to
   allocate space for the struct and "free_xxx()" to free up the space. */


SYMB *mkconst( int  n )

/* In "mkconst()" we check if the constant is one of the predefined ones, and
   if so use it, otherwise we create a new entry for it. Note that this wastes
   space, since we should check if we have used any constant before and return
   a pointer to an existing node if possible. However the technique of just
   predefining the first few constants (which make up the majority used) is
   a good compromise that is efficient. */

{
	if((n >= 0) && (n < CONST_MAX))
		return const_tab[n] ;
	else
	{
		SYMB *c = get_symb() ;   /* Create a new node */

		c->type = T_INT ;
		c->VAL1 = n ;
		return c ;
	}

}	/* SYMB *mkconst( int  n ) */


SYMB *mklabel( int  l )

/* Make a label node with the given value */

{
	SYMB *t = get_symb() ;

	t->type = T_LABEL ;
	t->VAL1 = l ;

	return t ;

}	/* SYMB *mklabel( int  l ) */


SYMB *mktmp( void )

/* Make a temporary name. This is just a var with name of the form Txxx. We
   force a temporary name into the lexical analyser text buffer, "yytext[]" and
   then use the lexical analyser's name allocator "mkname()". */

{
        SYMB *tmp, *hold ;

        /* yylval may hold the most recent lexeme, so save it */

        hold = yylval.symb ;

	/* Make the name with mkname */

	sprintf( yytext, "T%d", next_tmp++ ) ;   /* Set up text */
	yyleng = strlen( yytext ) ;
	mkname() ;
	yylval.symb->type = T_VAR ;

        /* Restore yylval and return the temporary name */

        tmp = yylval.symb ;
        yylval.symb = hold ;
	return tmp ;

}	/* SYMB *mktmp( void ) */


SYMB *get_symb( void )

/* Allocate space for a symbol table entry. Note the use of the freelist
   "symb_list" to hold any nodes that have been returned. If none is available
   we use "malloc()" to obtain a new node. Rather than use "malloc()" direct we
   call our own version "safe_malloc()". This guarantees to return a valid
   pointer (and never NULL). If store has run out and safe_malloc() cannot
   allocate a new structure it will print an error message and exit the
   compiler. */

{
	SYMB *t ;

	if( symb_list != NULL )
	{
		t         = symb_list ;
		symb_list = symb_list->next ;
	}
	else
		t = (SYMB *)safe_malloc( sizeof( SYMB )) ;

	return t ;

}	/* SYMB *get_symb( void ) */


void  free_symb( SYMB *s )

/* This is the sister routine to "get_symb()" and just adds the symbol node to
   the freelist for reuse. */

{
	s->next   = symb_list ;
	symb_list = s ;

}	/* void  free_symb( SYMB *s ) */


ENODE *get_enode( void )

/* Allocate for ENODE. This routine and "free_enode()" are analagous to
   "get_symb()" and "free_symb()". */

{
	if( enode_list != NULL )
	{
		ENODE *expr ;

		expr       = enode_list ;
		enode_list = expr->next ;

		return expr ;
	}
	else
		return (ENODE *)safe_malloc( sizeof( ENODE )) ;

}	/* ENODE *get_enode( void ) */


void  free_enode( ENODE *expr )

/* Return an enode for reuse */

{
	expr->next = enode_list ;
	enode_list = expr ;

}	/* void  free_enode( ENODE *expr ) */


void *safe_malloc( int  n )

/* Rather than have a test for a null pointer each time we call "malloc()" in
   the compiler we write our own safe version, "safe_malloc()".  If memory runs
   out there is no more we can do, and so the routine aborts the entire
   compilation. */

{
	void *t = malloc( n ) ;

	/* Check we got it */

	if( t == NULL )
	{
		error( "malloc() failed" ) ;
		exit( 0 ) ;
	}

	return t ;

}	/* void *safe_malloc( int  n ) */


/* A couple of routine for allocating and joining TAC lists. We need not
   maintain a freelist for TAC, since we never free a TAC quadruple once
   allocated. */


TAC *mktac( int   op,			 /* Operator */
	    SYMB *a,			 /* Result */
	    SYMB *b,			 /* Operands */
	    SYMB *c )

/* Construct a TAC quadruple with the given fields 

	a := b op c

   Note the use of #defined selectors VA, VB and VC for the TAC struct. If
   efficiency became a worry we might chose not to call "safe_malloc()" each
   time we wanted a new qaudruple, but to allocate several at once. */

{
	TAC *t = (TAC *)safe_malloc( sizeof( TAC )) ;

	t->next  = NULL ;		 /* Set these for safety */
	t->prev  = NULL ;
	t->op    = op ;
	t->VA   = a ;
	t->VB = b ;
	t->VC = c ;

	return t ;

}	/* TAC *mktac( int   op,
	    	       SYMB *a,
	    	       SYMB *b,
	    	       SYMB *c ) */


TAC *join_tac( TAC *c1,
	       TAC *c2 )

/* Join two pieces of TAC together.  Remember that in the parser we always
   refer to a TAC list by the most recently generated piece of code and so we
   follow the prev pointer to get the preceding instructions. We will end up
   with a pointer to a TAC list for the parser representing the code of "c1"
   followed by that of "c2". */

{
	TAC *t ;

	/* If either list is NULL return the other */

	if( c1 == NULL )
		return c2 ;

	if( c2 == NULL )
		return c1 ;

	/* Run down c2, until we get to the beginning and then add c1 */

	t = c2 ;

	while( t->prev != NULL )
		t = t->prev ;

	t->prev = c1 ;
	return c2 ;

}	/* TAC *join_tac( TAC *c1,
			  TAC *c2 ) */


/* These are the symbol table routines. We have a routine, "insert()", to
   insert a node in the symbol table (created by one of the "mkxxx()" routines)
   and a routine, "lookup()" to find the symbol table entry, if any, for a
   given text name. Both routines use the hashing function "hash()" described
   in chapter 5. */


void  insert( SYMB *s )

/* Insert a new symbol in the symbol table. We hash on a text first argument */

{
	int hv = hash( s->TEXT1 ) ;

	s->next = symbtab[hv] ;		 /* Insert at head */
	symbtab[hv]  = s ;

}	/* void  insert( SYMB *s ) */


int  hash( char *s )

/* Return a hashvalue from the given text. We use the bottom nybble of each
   character ORed with the top nybble of the hashvalue so far and shifted in at
   the bottom. This is then reduced mod the size of the hash table. Note the
   implicit assumption that we are on a 32 bit machine. */

{
	int  hv = 0 ;
	int  i ;

	for( i = 0 ; s[i] != EOS ; i++ )
	{
		int  v = (hv >> 28) ^ (s[i] & 0xf) ;

		hv = (hv << 4) | v ;
	}

	hv = hv & 0x7fffffff ;		 /* Ensure positive */
	return hv % HASHSIZE ;

}	/* int  hash ( char *s ) */


SYMB *lookup( char *s )

/* Lookup a name in the hashtable. Return NULL if the name is not found. */

{
	int   hv = hash( s ) ;
	SYMB *t  = symbtab[hv] ;

	while( t != NULL )		 	  /* Look for the name */
		if( strcmp( t->TEXT1, s ) == 0 )
			break ;
		else
			t = t->next ;

	return t ;			 /* NULL if not found */

}	/* SYMB lookup( char *s ) */


/* We now have a couple of routines for debugging purposes. */


void  print_instr( TAC *i )

/* "print_instr()" is used to print out a TAC instruction symbolically. We use
   it in the code generator to print each TAC instruction as a comment before
   the code generated for it. The subsidiary routine, "ts()" is used to obtain
   a suitable string representation of the TAC arguments. Note the clumsy
   programming assumption that arguments can be represented in 11 characters.
*/ 


{
	char sa[12] ;			 /* For text of TAC args */
	char sb[12] ;
	char sc[12] ;

	printf( "       ", i ) ;

	switch( i->op )
	{
	case TAC_UNDEF:

		printf( "undef\n" ) ;
		break ;

	case TAC_ADD:

		printf( "%s := %s + %s\n", ts( i->VA, sa ), ts( i->VB, sb ),
			ts( i->VC, sc )) ;
		break ;

	case TAC_SUB:

		printf( "%s := %s - %s\n", ts( i->VA, sa ), ts( i->VB, sb ),
			ts( i->VC, sc )) ;
		break ;

	case TAC_MUL:

		printf( "%s := %s * %s\n", ts( i->VA, sa ), ts( i->VB, sb ),
			ts( i->VC, sc )) ;
		break ;

	case TAC_DIV:

		printf( "%s := %s / %s\n", ts( i->VA, sa ), ts( i->VB, sb ),
			ts( i->VC, sc )) ;
		break ;

	case TAC_NEG:

		printf( "%s := - %s\n", ts( i->VA, sa ), ts( i->VB, sb )) ;
		break ;

	case TAC_COPY:

		printf( "%s := %s\n", ts( i->VA, sa ), ts( i->VB, sb )) ;
		break ;

	case TAC_GOTO:

		printf( "goto L%d\n", i->LA->VA->VAL1 ) ;
		break ;

	case TAC_IFZ:

		printf( "ifz %s goto L%d\n", ts( i->VB, sb ),
		 	i->LA->VA->VAL1 ) ;
		break ;

	case TAC_IFNZ:

		printf( "ifnz %s goto L%d\n", ts( i->VB, sb ),
			i->LA->VA->VAL1 ) ;
		break ;

	case TAC_ARG:

		printf( "arg %s\n", ts( i->VA, sa )) ;
		break ;

	case TAC_CALL:

		if( i->VA == NULL )
			printf( "call L%d\n", i->LB->VA->VAL1 ) ;
		else
			printf( "%s = call L%d\n", ts( i->VA, sa ),
				i->LB->VA->VAL1 ) ;
		break ;

	case TAC_RETURN:

		printf( "return %s\n", ts( i->VA, sa )) ;
		break ;

	case TAC_LABEL:

		printf( "label L%d\n", i->VA->VAL1 ) ;
		break ;

	case TAC_VAR:

		printf( "var %s\n", ts( i->VA, sa )) ;
		break ;

	case TAC_BEGINFUNC:

		printf( "beginfunc\n" ) ;
		break ;

	case TAC_ENDFUNC:

		printf( "endfunc\n" ) ;
		break ;

	default:

		/* Don't know what this one is */

		error( "unknown TAC opcode" ) ;
		printf( "unknown %d\n", i->op ) ;
		break ;
	}

	fflush( stdout ) ;

}	/* print_instr( i ) */


char *ts( SYMB *s,			 /* Symbol to translate */
	  char *str )			 /* String to put it in */

/* Return the string representation of the given symbol. Permissible ones are
   functions, vars, temporaries or constants */

{

	/* Check we haven't been given NULL */

	if( s == NULL )
		return "NULL" ;

	/* Identify the type */

	switch( s->type )
	{
	case T_FUNC:
	case T_VAR:

		/* Just return the name */

		return s->TEXT1 ;

	case T_TEXT:

		/* Put the address of the text */

		sprintf( str, "L%d", s->VAL2 ) ;
		return str ;

	case T_INT:

		/* Convert the number to string */

		sprintf( str, "%d", s->VAL1 ) ;
		return str ;

	default:

		/* Unknown arg type */

		error( "unknown TAC arg type" ) ;
		return "?" ;
	}

}	/* ts( SYMB *s,
	       char *str ) */


void  error( char *str )

/* This is a very simple error message routine. This is just prints a message
   to the standard error stream, and sets a flag to indicate that an error has
   occurred. If this is set at the end of parsing, then we do not carry on
   further with code generation. */

{
	fprintf( stderr, "vc: %s\n", str ) ;
	errors_found = TRUE ;

}	/* void  error( char *str ) */
//E*O*F main.c//

echo x - optimize.c
mv optimize.c optimize.c.old
cat > "optimize.c" << '//E*O*F optimize.c//'
/******************************************************************************
*******************************************************************************


            OOO   PPPP   TTTTT  IIIII  M   M  IIIII  ZZZZZ  EEEEE
           O   O  P   P    T      I    MM MM    I        Z  E
           O   O  P   P    T      I    M M M    I       Z   E
           O   O  PPPP     T      I    M M M    I      Z    EEEE
           O   O  P        T      I    M   M    I     Z     E
           O   O  P        T      I    M   M    I    Z      E
            OOO   P        T    IIIII  M   M  IIIII  ZZZZZ  EEEEE


*******************************************************************************
*******************************************************************************

                             An Optimizer for VSL
                             ====================

   This optimizer is a multi-pass optimizer, performing peephole, local and
   global optimizations.  Designed only for use with SINGLE function programs.

   Modifications:
   ==============

   May 15 91 JRJ:  First version (Jonathan R. Johnson, Carleton College)

*******************************************************************************
******************************************************************************/

#include <stdio.h>
#include "vc.h"

#define MAX_BLOCKS 200              /* Limit on basic block count */
#define SHOWALL    FALSE            /* Flag for showing all data-flow info */

#define DI data.in                  /* For ease of use, abbreviations for */
#define DK data.kill                /* data-flow information fields       */
#define DG data.gen
#define DO data.out
#define GI global->in
#define GG global->gen
#define GK global->kill
#define GO global->out

#define B_STAT   0                  /* Block types for control-flow data */
#define B_GOTO   1
#define B_IF     2
#define B_END    3

typedef struct data {               /* Data-flow information record */
  long gen, kill, in, out;
} DATA;

typedef struct slist {              /* Linked list statement structure: */
  struct slist *prev, *next;        /*   Links to next, prev statments  */
  TAC          *tac;                /*   Pointer to tac segment         */
  DATA          data;               /*   Data-flow info record          */
} SLIST;

typedef struct bb {                 /* Graph structure for basic blocks:     */
  unsigned char   next1, next2;     /*   Indices to one or both successors   */
  unsigned char   prev1, prev2;     /*   Indices to one or both predecessors */
  unsigned char   type;             /*   Flag for the block type             */
  unsigned char   n;                /*   Multi-purpose: branch or flag...    */
  SLIST          *sl;               /*   Pointer to statement list           */
  unsigned char   defbase;          /*   First local def in def table        */
  unsigned char   defptr;           /*   Index to next free def in table     */
  unsigned char   change;           /*   Flag for data-flow analysis         */
  DATA            data;             /*   Local data-flow analysis record     */
} BB;

int             LL;                 /* Bit count of long integer         */
int             helpful;            /* Global flag for code improvement  */
DATA           *global;             /* Global data-flow analysis record  */
BB             *bbl[MAX_BLOCKS];    /* Basic block array                 */
SLIST         **defs;               /* Pointer to definition table       */
unsigned char   gdefptr;            /* Global index to free def in table */
FILE           *outfile = NULL;     /* Output file for info              */

/* Procedure prototypes */

void           optimize(TAC *tls);
void           init_op(TAC *tls);
void           improve_function();
void           join_blocks(unsigned char n, unsigned char *m, DATA *joined);
void           improve_block(unsigned char n);
void           local_copy_prop(unsigned char n);
void           local_sub_expr_elim(unsigned char n);
void           local_dead_code_elim(unsigned char n);
void           data_flow_analyze(unsigned char n);

void           global_copy_prop();
void           global_sub_expr_elim();
void           global_dead_code_elim();
void           copy_prop_search(unsigned char n, TAC *t2, int i, int prhead);
void           sub_expr_search(unsigned char n, TAC *t2, int i, int prhead);
int            use_search(unsigned char n, SYMB *v, int i);

void           unvisit_all();
int            peephole(TAC *t);
int            sort_cmtv(TAC *t);
int            const_fold(TAC *t);
unsigned char  find_dest(unsigned char label);
long           kill_all(SYMB *s);
void           fprint_instr(TAC *i);
void           data_out(DATA d);


void optimize(TAC *tls) {
  
  /*
   *  This is the main function call, called by MAIN.C, which takes TAC as
   *  its input, forms a basic block control-flow graph, and then runs
   *  optimization routines on the graph.
   *
   *  The optimizer may be used in one of two ways:
   *
   *    $ vc -O <f.vsl >f.vas             # include optimization in the compile
   *    $ vc -O trace <f.vsl >f.vas       # optimize and create a trace file
   *
   *  In the latter case, the file 'trace' will show the mechanism and method
   *  of the optimizations.  In either case, comments attatched to 'f.vas' will
   *  indicate that the optimization has been performed.
   *
   *  If data-flow information output is desired for every TAC statement, set
   *  the constant SHOW_ALL to TRUE.  Reams of output _will_ result.
   */
  
  int i;
  
  init_op(tls);                     /* Create basic block graph */
  
  helpful = TRUE;
  
  while (helpful) {
    
    for (i = 0; i < LL; i++)        /* Clear definitions */
      defs[i] = NULL;
    
    helpful = FALSE;
    improve_function();             /* Perform transformations on code */
  }
  
  if (outfile)
    fclose(outfile);
}


void init_op(TAC *tls) {
  
  /*
   *  Optimizer initialization.  The tac statments are grouped into basic
   *  blocks, and each block records information about its end condition
   *  (e.g. goto, endfunc).  Statements are peephole-optimized as they are
   *  inserted into the basic block data structure, and changes noted as made.
   *  We also initialize data-flow analysis structures and records.
   */
  
  unsigned char bbptr;              /* Basic block array index        */
  char bbnow, bt, bl;               /* Block end flag, type and label */
  int i;
  TAC *t;
  SLIST *s;
  BB *b;
  
  LL = 8 * sizeof(long);            /* Set LL to the size of long in bits */
  
  bbnow = FALSE;                    /* Initialize block information data */
  bbptr = bt = bl = 0;
  
  printf("\\        Optimizing...\n");
  
  if (*filename) {
    printf("\\        Tracing optimization to %s.\n", filename);
    outfile = fopen(filename, "w");
  }
  
  /* The first statement always begins a basic block */
  
  b = bbl[bbptr++] = (BB *) safe_malloc(sizeof(BB));
  s = b->sl = (SLIST *) safe_malloc(sizeof(SLIST));
  s->tac = tls;
  s->prev = NULL;
  
  if (outfile) {
    fprintf(outfile, "-- Block 0\n");    
    fprint_instr(tls);
  }
  
  if (peephole(tls) && outfile) {
    fprintf(outfile, "   =\n");
    fprint_instr(tls);
  }
  
  /* Run through the tac list, forming basic blocks with identifying info */
  
  for (t = tls->next; t; t = t->next) {
    if ((t->op == TAC_LABEL) || (bbnow)) {
      
      /* Finish the current basic block and start a new one */
      
      bbnow     = FALSE;
      b->type   = bt;
      b->n      = bl;
      s->next   = NULL;
      b->change = TRUE;
      b->defptr = 0;
      b->prev1  = MAX_BLOCKS;
      b->prev2  = MAX_BLOCKS;
      if (outfile)
        fprintf(outfile, "  (type=%d, lab=%d)\n-- Block %d\n", bt, bl, bbptr);
      
      bt = B_STAT;
      bl = 0;
      if (bbptr >= MAX_BLOCKS) {
        error("Number of basic blocks too large.");
        exit(0);
      }
      b = bbl[bbptr++] = (BB *) safe_malloc(sizeof(BB));
      s = b->sl = (SLIST *) safe_malloc(sizeof(SLIST));
      s->prev = NULL;
    }
    
    else {                          /* continue with current block */
      
      /* Add a new statement structure onto the current block's list */
      
      s->next = (SLIST *) safe_malloc(sizeof(SLIST));
      s->next->prev = s;
      s = s->next;
    }
    
    s->tac = t;                     /* Add tac statement to basic block */
    
    switch (t->op) {                /* Check for block end, store info */
    case TAC_GOTO:
      bbnow = TRUE;
      bt    = B_GOTO;
      bl    = t->LA->VA->VAL1;
      break;
    case TAC_IFZ:
    case TAC_IFNZ:
      bbnow = TRUE;
      bt    = B_IF;
      bl    = t->LA->VA->VAL1;
      break;
    case TAC_ENDFUNC:
      bt = B_END;
    }
    
    if (outfile)
      fprint_instr(t);
    if (peephole(t) && outfile) {
      fprintf(outfile, "   =\n");
      fprint_instr(t);
    }
  }
  
  b->type   = bt;                   /* Store info for last basic block */
  b->n      = bl;
  s->next   = NULL;
  b->change = TRUE;
  b->defptr = 0;
  b->prev1  = MAX_BLOCKS;
  b->prev2  = MAX_BLOCKS;
  if (outfile)
    fprintf(outfile, "  (type=%d, lab=%d)\n", bt, bl);
  
  /* Set flow-of-control pointers to the appropriate basic blocks */
  
  for (bbptr = 0; bbl[bbptr] && bbptr < MAX_BLOCKS; bbptr++) {
    b = bbl[bbptr];
    switch(b->type) {
    case B_STAT:
      b->next1 = bbptr + 1;
      b->next2 = MAX_BLOCKS;
      bbl[b->next1]->prev1 = bbptr;
      break;
    case B_GOTO:
      b->next1 = find_dest(b->n);
      b->next2 = MAX_BLOCKS;
      bbl[b->next1]->prev2 = bbptr;
      break;
    case B_IF:
      b->next1 = bbptr + 1;
      bbl[b->next1]->prev1 = bbptr;
      b->next2 = find_dest(b->n);
      bbl[b->next2]->prev2 = bbptr;
      break;
    case B_END:
      b->next1 = MAX_BLOCKS;        /* Signal endfunc with special value */
      b->next2 = MAX_BLOCKS;
    }
  }
  
  /* Initialize data-flow analysis records */
  
  global = (DATA *) safe_malloc(sizeof(DATA));
  
  defs = (SLIST **) safe_malloc(LL * sizeof(SLIST *));
}


void improve_function() {
  
  /* 
   *  Optimize the blocks locally in their control-flow structure, then
   *  globally optimize.
   */
  
  unsigned char  n, m;
  BB            *b, *f = bbl[0];
  
  f->defbase = f->defptr = 0;
  f->DI = 0;
  
  improve_block(0);                 /* Optimize first basic block */
  GI = f->DI;
  GG = f->DG;
  GK = f->DK;
  GO = f->DO;
  gdefptr = f->defptr;
  
  n = 0;
  m = f->next1;
  
  if (m < MAX_BLOCKS) {             /* If there is a second block, prepare */
    b = bbl[m];                     /* for the join_blocks procedure       */
    b->defbase = gdefptr;
    b->DI      = GO;
    improve_block(m);
    gdefptr = b->defptr;
  }
  
  while (m < MAX_BLOCKS)
    join_blocks(n, &m, global);     /* Recursively optimize other blocks */
  
  if (outfile) {
    fprintf(outfile, "\nGlobal data-flow information after local improv.\n");
    data_out(*global);
  }
  
  global_copy_prop();               /* Optimize function using global data */
  global_sub_expr_elim();
  global_dead_code_elim();
}


void join_blocks(unsigned char n, unsigned char *m, DATA *joined) {
  
  /* 
   *  Join blocks together in accordance with data-flow analysis rules.  The
   *  basic strategy is to take two optimized blocks, bbl[n] and bbl[*m] and
   *  perform data-flow analysis calculations with the set of joined data and
   *  with bbl[*m] or its "equivalent" block.  IF->THEN->ELSE and LOOP
   *  structures are collapsed to such equivalent blocks so that they may be
   *  joined with the other statements in step-wise fashion.
   *
   *  The function is called recursively to produce collapsed equivalent
   *  blocks, and a global definition pointer, gdefptr, is used to direct the
   *  appropriate placement of basic block definitions.  The variable n
   *  represents the root of the control-flow structure being considered, while
   *  m, a pointer to a basic block list index, is used to traverse the
   *  descendants of n.
   */
  
  unsigned char    t;
  DATA            *d1, *d2;
  BB              *b1 = bbl[n], *b2 = bbl[*m], *b3;
  SLIST           *s;
  
  switch(b1->type) {
    
  case B_STAT:
    
    /* The root is a statement block */
    
    d1 = &(b2->data);               /* Assume that bbl[*m] is ready to join */
    
    switch(b2->type) {
      
    case B_STAT:
      
      /*
       *  n's descendant is of type B_STAT; just prepare the following block
       *  for joining and then go on to update the joined data-flow info.
       */
      
      if (outfile)
        fprintf(outfile, "\nSTAT->STAT\n");
      
      *m = b2->next1;               /* Get following block and improve it */
      b3 = bbl[*m];
      b3->defbase = gdefptr;
      b3->DI     = b2->DO;
      improve_block(*m);
      gdefptr = b3->defptr;
      
      break;
      
    case B_IF:
      
      /*
       *  n's descendant is the top of an IF structure; collapse it and then
       *  go on, treating the resulting data-flow information as that of a
       *  regular statement.
       */
      
      if (outfile)
        fprintf(outfile, "\nSTAT->IF\n");
      
      /*
       *  Create a new set of data-flow information, setting it equal to the
       *  data-flow info of n's current descendant.
       */
      
      d1 = (DATA *) safe_malloc(sizeof(DATA));
      d1->in   = b2->DI;
      d1->gen  = b2->DG;
      d1->kill = b2->DK;
      d1->out  = b2->DO;
      
      t = *m;                       /* Prepare *m's descendant and recurse */
      *m = b2->next1;
      b3 = bbl[*m];
      b3->defbase = gdefptr;
      b3->DI      = b2->DO;
      improve_block(*m);
      gdefptr = b3->defptr;
      join_blocks(t, m, d1);
      
      /* Now we are ready to join data-flow info with the equivalent block */
      
      if (outfile)
        fprintf(outfile, "\nSTAT->STAT\n");
      
      break;
      
    case B_END:
      
      /* The current descendant of n is the last block, we are done. */
         
      if (outfile)
        fprintf(outfile, "\nSTAT->END\n");
      *m = b2->next1;
    }
    
    /* Data-flow equations for joining statemement blocks */
    
    joined->gen  = d1->gen | joined->gen & ~d1->kill;
    joined->kill = d1->kill | joined->kill & ~d1->gen;
    joined->out  = d1->out;
    
    if (outfile) {
      fprintf(outfile, "\nJoined data-flow information after STAT->xxx\n");
      data_out(*joined);
    }
    
    break;
    
  case B_IF:
    
    /* The root is an if block; non-goto descendants elicit a recursion */
    
    switch (b2->type) {
      
    case B_STAT:
      
      /* n's descendant is a statement block; we will recurse */
      
      if (outfile)
        fprintf(outfile, "\nIF->STAT\n");
      break;
      
    case B_GOTO:
      
      /* n's descendant is a goto block; either a LOOP or ELSE exists */
      
      if (outfile)
        fprintf(outfile, "\nIF->GOTO\n");
      d1 = &(b2->data);
      break;
      
    case B_IF:
      
      /* n's descendant is an if block; we will recurse */
      
      if (outfile)
        fprintf(outfile, "\nIF->IF\n");
    }
    
    if (b2->type != B_GOTO) {
      
      /*
       *  For all non-goto descendants, we recurse to make an equivalent goto
       *  block starting with the descendant's data-flow info.
       */
      
      d1 = (DATA *) safe_malloc(sizeof(DATA));
      d1->in   = b2->DI;
      d1->gen  = b2->DG;
      d1->kill = b2->DK;
      d1->out  = b2->DO;
      
      t = *m;                       /* Prepare the next block for recursion */
      *m = b2->next1;
      b3 = bbl[*m];
      b3->defbase = gdefptr;
      b3->DI      = b2->DO;
      improve_block(*m);
      gdefptr = b3->defptr;
      
      do                            /* Recurse until goto block is found */
        join_blocks(t, m, d1);
      while (bbl[*m]->type != B_GOTO);
      
      /* Goto block has been reached; include its data-flow info */
      
      b2 = bbl[*m];
      d1->gen  = b2->DG | d1->gen & ~b2->DK;
      d1->kill = b2->DK | d1->kill & ~b2->DG;
      d1->out  = b2->DO;
    }
    
    /*
     *  Two possible outcomes here; either the goto is to the root block (a
     *  loop structure is formed), or not (an else structure is formed).
     */
    
    if (b2->next1 == n) {
      
      /*
       *  A loop structure has been formed; double the data-flow info back to
       *  the top of the loop and re-traverse the intervening blocks.
       */
      
      if (outfile)
        fprintf(outfile, "\nLOOP FORMED\n");
      
      b1->DI |= d1->out;            /* Include out[b2] in in[b1] */
      improve_block(n);             /* Redo n's data-flow info */
      
      *m = b1->next1;               /* Restart m at n's left child */
      b2 = bbl[*m];
      b2->DI = b1->DO;              /* Update b2[in] */
      improve_block(*m);            /* Redo *m's data-flow info */
      
      /* Again, a non-goto descendant recursion(s) to find goto block */
      
      if (b2->type != B_GOTO) {
        
        d1->in   = b2->DI;          /* Reset joined data for recursion */
        d1->gen  = b2->DG;
        d1->kill = b2->DK;
        d1->out  = b2->DO;
        
        t = *m;                     /* Prepare the next block for recursion */
        *m = b2->next1;
        b3 = bbl[*m];
        b3->DI = b2->DO;
        improve_block(*m);
        gdefptr = b3->defptr;
        
        do                          /* Recurse until goto block is found */
          join_blocks(t, m, d1);
        while (bbl[*m]->type != B_GOTO);
        
        /* Loop has been traversed; include goto block's data-flow info */
        
        b2 = bbl[*m];
        d1->gen  = b2->DG | d1->gen & ~b2->DK;
        d1->kill = b2->DK | d1->kill & ~b2->DG;
        d1->out  = b2->DO;
      }
      
      if (outfile) {
        fprintf(outfile, "\nLoop branch data-flow information\n");
        data_out(*d1);
      }
      
      *m = b1->next2;               /* Prepare n's right child */
      b3 = bbl[*m];
      b3->defbase = gdefptr;
      b3->DI      = d1->out;
      improve_block(*m);
      gdefptr = b3->defptr;
    }
    
    else {
      
      /*
       *  An else structure has been formed; traverse n's right branch to
       *  produce data-flow info for the then structure, and do the appropriate
       *  data-flow calculations.
       */
      
      if (outfile)
        fprintf(outfile, "\nELSE BODY COMPLETED\n");
      
      t  = b1->next2;               /* Prepare n's right child for recursion */
      b3 = bbl[t];
      b3->defbase = gdefptr;
      b3->DI      = b1->DO;
      improve_block(t);
      gdefptr = b3->defptr;
      
      /* Use right child's data-flow info as joined data in the recursion */
      
      d2 = (DATA *) safe_malloc(sizeof(DATA));
      d2->in   = b3->DI;
      d2->gen  = b3->DG;
      d2->kill = b3->DK;
      d2->out  = b3->DO;
      
      *m = b3->next1;               /* Begin traversal with left child */
      
      /*
       *  Prepare a descendant and recurse until we find the block that joins
       *  the else and then stuctures.
       */
      
      while (*m != b2->next1) {
        b3 = bbl[*m];
        b3->defbase = gdefptr;
        b3->DI      = d2->out;
        improve_block(*m);
        gdefptr = b3->defptr;
        join_blocks(t, m, d2);
      }
      
      if (outfile)
        fprintf(outfile, "\nTHEN BODY COMPLETED\n");
      
      /* Data-flow equations for then and else structures */
      
      d1->gen  |= d2->gen;
      d1->kill &= d2->kill;
      d1->out  |= d2->out;
      
      /* d1 is now an equivalent statement */
      
      if (outfile) {
        fprintf(outfile, "\nIf-else data-flow information\n");
        data_out(*d1);
      }
      
      *m = b3->next1;               /* Prepare the joint descendant */
      b3 = bbl[*m];
      b3->defbase = gdefptr;
      b3->DI      = d1->out;
      improve_block(*m);
      gdefptr = b3->defptr;
    }
    
    /*
     *  We now have an equivalent statement block in d1; do the appropriate
     *  data-flow analysis calculations.
     */
    
    joined->gen  = d1->gen | joined->gen & ~d1->kill;
    joined->kill = d1->kill | joined->kill & ~d1->gen;
    joined->out  = d1->out;
    
    if (outfile) {
      fprintf(outfile, "\nJoined data-flow information after IF->xxx\n");
      data_out(*joined);
    }
  }
}


void improve_block(unsigned char n) {
  
  /*
   *  Do local optimization on this block; if no changes have occured, just
   *  recalculate the block's data-flow information.
   */
  
  BB *b = bbl[n];
  
  if (!b->change)
    data_flow_analyze(n);
  else {
    while(b->change) {
      data_flow_analyze(n);
      local_copy_prop(n);
      local_sub_expr_elim(n);
      local_dead_code_elim(n);
    }
  }
}


void local_copy_prop(unsigned char n) {
  
  /*
   *  Eliminate copy propagations in the basic block.  With each local
   *  definition that performs a copy, "propagate" the copy down through the
   *  statement list until the list ends or until either variable in the copy
   *  is changed.
   */
  
  int i, prhead;                    /* prhead keeps us from reprinting stuff */
  BB *b = bbl[n];
  SLIST *s;
  TAC *t1, *t2;
  
  if (outfile)
    fprintf(outfile, "\n** Local copy propagation scan **\n");
  
  for (i = b->defbase; i < b->defptr; i++) {
    s = defs[i];
    if (s->tac->op == TAC_COPY) {
      prhead = TRUE;
      t2 = s->tac;
      
      /* A copy has been found; run through remaining statements */
      
      for (s = s->next; s; s = s->next) {
        t1 = s->tac;
        
        /*
         *  Break if either copy statement variable is changed;  ARG and
         *  RETURN do not change their argument -- we are assuming single
         *  functions, and thus the only calls will be to the non-destructive
         *  PRINT routines in the library.  It is likeley that RETURN will not
         *  be used in a single function, but we leave it in for convenience.
         *  Also, a variable is unchanged if set equal to itself.
         */
        
        if ((t1->VA == t2->VA || t1->VA == t2->VB) &&
            !(t1->op == TAC_ARG || t1->op == TAC_RETURN) &&
            !(t1->op == TAC_COPY && t1->VA == t1->VB))
          break;
            
        if (t1->VA == t2->VA && (t1->op == TAC_ARG || t1->op == TAC_RETURN) ||
            t1->VB == t2->VA || t1->VC == t2->VA) {
          
          /* Propagate the copy */
          
          if (outfile) {
            if (prhead) {
              fprintf(outfile, "\nEliminating copy propagation:");
              fprint_instr(t2);
              prhead = FALSE;
            }
            fprintf(outfile, "\n");
            fprint_instr(t1);
            fprintf(outfile, "     v\n");
          }
          
          if (t1->VA == t2->VA && (t1->op == TAC_ARG || t1->op == TAC_RETURN))
            t1->VA = t2->VB;
          if (t1->VB == t2->VA)
            t1->VB = t2->VB;
          if (t1->VC == t2->VA)
            t1->VC = t2->VB;
          b->change = TRUE;
          if (outfile)
            fprint_instr(t1);
          if (peephole(t1) && outfile) {
            fprintf(outfile, "   =\n");
            fprint_instr(t1);
          }
        }
      }
    }
  }
}


void local_sub_expr_elim(unsigned char n) {
  
  /*
   *  Eliminate common subexpressions in the basic block.  With each local
   *  definition that calculates a sub-expression, eliminate all subsequent
   *  similar calculations in the statement list until the list ends or until
   *  any variable in the expression statement is changed.
   */
  
  int i, prhead;
  BB *b = bbl[n];
  SLIST *s;
  TAC *t1, *t2;
  
  if (outfile)
    fprintf(outfile, "\n** Local common sub-expression scan **\n");
  
  for (i = b->defbase; i < b->defptr; i++) {
    s = defs[i];
    if (s->tac->op >= TAC_ADD && s->tac->op <= TAC_NEG) {
      prhead = TRUE;
      t2 = s->tac;
      
      /* A sub-expression has been found; run through remaining statments */
      
      for (s = s->next; s; s = s->next) {
        t1 = s->tac;
        
        /* Break if any expression statement variable is changed */
        
        if (t1->VA == t2->VA || t1->VA == t2->VB || t1->VA == t2->VC)
          break;
        
        if (t1->op == t2->op && t1->VB == t2->VB && t1->VC == t2->VC) {
          
          /* Eliminate common sub-expression */
          
          if (outfile) {
            if (prhead) {
              fprintf(outfile, "\nEliminating common sub-expression:");
              fprint_instr(t2);
              prhead = FALSE;
            }
            fprintf(outfile, "\n");
            fprint_instr(t1);
            fprintf(outfile, "     v\n");
          }
          
          t1->op = TAC_COPY;
          t1->VB = t2->VA;
          t1->VC = NULL;
          b->change = TRUE;
          if (outfile)
            fprint_instr(t1);
          if (peephole(t1) && outfile) {
            fprintf(outfile, " =\n");
            fprint_instr(t1);
          }
        }
      }
    }
  }
}


void local_dead_code_elim(unsigned char n) {
  
  /*
   *  Eliminate dead code in the basic block.  With each local definition,
   *  check subsequent statements for any use of the definition's result.  If
   *  no use is found and the definition's result is a temporary variable, then
   *  that definition is dead.  If the definition's result is not a temporary,
   *  the definition is still dead if, being unused, it does not reach the end
   *  of the block.
   */
  
  char   name;                      /* Char to hold first letter of a var */
  int    i, used;
  BB    *b = bbl[n];
  SYMB  *v;
  SLIST *s;
  
  if (outfile)
    fprintf(outfile, "\n** Local dead code scan **\n");
  
  for (i = b->defbase; i < b->defptr; i++) {
    v = defs[i]->tac->VA;
    used = FALSE;
    s = defs[i]->next;
    
    /*
     *  Search for uses of the definition result; quit if definition is not
     *  "live" at the start of a statement.
     */
    
    for (; s && !used && (s->DI & 1 << i); s = s->next)
      if (s->tac->VB == v || s->tac->VC == v ||
          s->tac->VA == v && (s->tac->op == 10 || s->tac->op == 12))
        used = TRUE;
    
    name = *(defs[i]->tac->VA->TEXT1);
    
    /* If a non-temporary reaches the end of the statement list, save it. */
    
    if (!used && !s && name != 'T')
      used = TRUE;
    
    if (!used) {
      s = defs[i];
      
      /* Eliminate dead code */
      
      if (s->prev && name == 'T' && s->prev->tac->op == TAC_VAR) {
        
        /* Eliminate var Tn statement along with its definition */
        
        if (outfile) {
          fprintf(outfile, "\nEliminating");
          fprint_instr(s->prev->tac);
          fprintf(outfile, "Eliminating");
          fprint_instr(s->tac);
        }
        
        /* Renovate the statement list */
        
        if (s->prev->prev)
          s->prev->prev->next = s->next;
        else
          b->sl = s->next;
        if (s->next)
          s->next->prev = s->prev->prev;
        
        /* Renovate the TAC list */
        
        s->tac->prev->prev->next = s->tac->next;
        s->tac->next->prev = s->tac->prev->prev;
        
        free(s->prev->tac);         /* Abandon lost statments :( */
        free(s->prev);
        free(s->tac);
        free(s);
      }
      else {
        
        /* No associated var statement, so eliminate one statement only */
        
        if (outfile) {
          fprintf(outfile, "\nEliminating");
          fprint_instr(s->tac);
        }
        
        if (s->prev)                /* Renovate the statment list */
          s->prev->next = s->next;
        else
          b->sl = s->next;
        if (s->next)
          s->next->prev = s->prev;
        
        /* Renovate the TAC list */
        
        s->tac->prev->next = s->tac->next;
        s->tac->next->prev = s->tac->prev;
        
        free((void *) s->tac);      /* Abandon lost statement :( */
        free((void *) s);
      }
      b->change = TRUE;
    }
  }
}


void data_flow_analyze(unsigned char n) {
  
  /* Make definition table and calculate data flow analysis results */
  
  int    i;
  BB    *b = bbl[n];
  SLIST *s;
  TAC   *t;
  
  b->change = FALSE;
  
  if (outfile)
    fprintf(outfile, "\nDefinitions for block %d :\n", n);
  
  /* Unset old definitions */
  
  for (i = b->defbase; i < b->defptr; i++)
    defs[i] = NULL;
  
  b->defptr = b->defbase;           /* Reset definition table index */
  
  /* Insert definitions into the definition table, setting gen[s] en route */
  
  for (s = b->sl; s; s = s->next) {
    if (s->tac->op >= TAC_ADD && s->tac->op <= TAC_COPY) {
      if (b->defptr < LL) {
        s->DG = 1 << b->defptr;
        defs[b->defptr++] = s;
        if (outfile) {
          fprintf(outfile, "d%02d = ", b->defptr - 1);
          fprint_instr(s->tac);
        }
      }
      else
        s->DG = 0;
    }
  }
  
  if (outfile)
    fprintf(outfile, "\n");
  
  /* If defcount exceeds the long int binary capacity, signal an error */
  
  if (b->defptr >= LL && outfile)
    fprintf(outfile, "\n%d out of %d definitions were dropped.\n",
            b->defptr - LL, b->defptr - b->defbase);
  
  /* Generate in, gen, kill, and out for the statements and the block */
  
  b->DG = b->DK = 0;                /* gen[b] and kill[b] start at nil */
  
  b->sl->DI = b->DI;                /* Set in[s] for first statement */
  
  for (s = b->sl; s; s = s->next) {
    
    t = s->tac;
    
    /* If a := expr is defined, kill all other definitions of a */
    
    if (t->op >= TAC_ADD && t->op <= TAC_COPY || t->op == TAC_CALL && t->VA)
      s->DK = kill_all(t->VA) & ~s->DG;
    else
      s->DK = 0;
    
    /* Calculate out[s] */
    
    s->DO = s->DG | (s->DI & ~s->DK);
    
    /* Update gen[b] and kill[b] */
    
    b->DG = s->DG | (b->DG & ~s->DK);
    b->DK = s->DK | (b->DK & ~s->DG);
    
    if (s->next)
      s->next->DI = s->DO;          /* Pass off s[out] appropriately */
    else
      b->DO = s->DO;
    
    /* Output statement's data-flow information if appropriate */
    
    if (SHOWALL && outfile && b->defptr - b->defbase)
      switch (s->tac->op) {
      case TAC_UNDEF:
      case TAC_GOTO:
      case TAC_LABEL:
      case TAC_VAR:
      case TAC_BEGINFUNC:
      case TAC_ENDFUNC:
        break;
      default:
        fprint_instr(t);
        data_out(s->data);
        fprintf(outfile, "\n");
      }
  }
  
  if (outfile) {
    fprintf(outfile, "Block %d :\n", n);
    data_out(b->data);
  }
}


/*
 *  Global optimization routines.  Each operates by calling a recursive search
 *  procedure that will do the rest of the work.  In the first call, searches
 *  in out-of-range blocks will be produced, but this is for the sake of basic
 *  readability.  The alternative is putting two switch statements in every
 *  main routine.  If a bad call is performed, the search routine will return
 *  appropriately.
 */


void global_copy_prop() {
  
  /*
   *  Perform global copy propagation on the code.  For each copy definition,
   *  call the search routine on both children of its block.  All local copy
   *  propagations have already been done.  Don't bother with the last block.
   */
  
  int i, n;                         /* n is the basic block list index */
  BB *b;
  TAC *t;
  
  if (outfile)
    fprintf(outfile, "\n** Global copy propagation scan **\n");
  
  n = 0;
  for (b = bbl[n]; b->next1 != MAX_BLOCKS; b = bbl[++n]) {
    for (i = b->defbase; i < b->defptr; i++) {
      if (defs[i]->tac->op == TAC_COPY) {
        t = defs[i]->tac;
        unvisit_all();
        copy_prop_search(b->next1, t, i, TRUE);
        unvisit_all();
        copy_prop_search(b->next2, t, i, TRUE);
      }
    }
  }
}


void global_sub_expr_elim() {
  
  /*
   *  Perform global common sub-expression elimination on the code.  For each
   *  sub-expression definition, call the search routine on both children of
   *  its block.  All local sub-expression eliminations have already been done.
   *  Again, don't bother with the last block.
   */
  
  int i, n;                         /* n is the basic block list index */
  BB *b;
  TAC *t;
  
  if (outfile)
    fprintf(outfile, "\n** Global common sub-expression scan **\n");
  
  n = 0;
  for (b = bbl[n]; b->next1 != MAX_BLOCKS; b = bbl[++n]) {
    for (i = b->defbase; i < b->defptr; i++) {
      t = defs[i]->tac;
      if (t->op >= TAC_ADD && t->op <= TAC_NEG) {
        unvisit_all();
        sub_expr_search(b->next1, t, i, TRUE);
        unvisit_all();
        sub_expr_search(b->next2, t, i, TRUE);
      }
    }
  }
}


void global_dead_code_elim() {
  
  /*
   *  Perform global dead code elimination on the code.  For each definition,
   *  search for a use in its block and, if not locally used, call the search
   *  routine on both children of its block.  Note that when we reach the last
   *  block we will still search for uses, unlike the means of searching in the
   *  previous two functions.  We also do not care about the identity of a var;
   *  whether it is a temporary or a user-defined variable, its definition will
   *  be eliminated here if it goes unused.
   */
  
  int i, n, used;                   /* n is the basic block list index */
  BB *b;
  SLIST *s;
  SYMB *v;
  
  if (outfile)
    fprintf(outfile, "\n** Global dead code scan **\n");
  
  n = 0;
  do {
    b = bbl[n++];
    for (i = b->defbase; i < b->defptr; i++) {
      v = defs[i]->tac->VA;
      
      /* Check for local use */
      
      used = FALSE;
      s = defs[i]->next;
      for (; s && !used && (s->DI & 1 << i); s = s->next)
        if (s->tac->VB == v || s->tac->VC == v ||
            s->tac->VA == v && (s->tac->op == 10 || s->tac->op == 12))
          used = TRUE;
      
      /* If not used here, search on.  Otherwise, don't bother going further */
      
      if (!used) {
        unvisit_all();
        used = use_search(b->next1, defs[i]->tac->VA, i);
        unvisit_all();
        used |= use_search(b->next2, defs[i]->tac->VA, i);
      }
      
      if (!used) {
        s = defs[i];
        
        /* Eliminate dead code */
        
        if (*(s->tac->VA->TEXT1) == 'T' && s->prev->tac->op == TAC_VAR) {
          
          /* Eliminate var Tn statement along with its definition */
          
          if (outfile) {
            fprintf(outfile, "\nEliminating");
            fprint_instr(s->prev->tac);
            fprintf(outfile, "Eliminating");
            fprint_instr(s->tac);
          }
          
          /* Renovate the statment list */
          
          if (s->prev->prev)
            s->prev->prev->next = s->next;
          else
            b->sl = s->next;
          if (s->next)
            s->next->prev = s->prev->prev;
          
          /* Renovate the TAC list */
          
          s->tac->prev->prev->next = s->tac->next;
          s->tac->next->prev = s->tac->prev->prev;
          
          free(s->prev->tac);       /* Abandon lost statements :( */
          free(s->prev);
          free(s->tac);
          free(s);
        }
        else {
          
          /* No associated var statement, so eliminate one statement only */
          
          if (outfile) {
            fprintf(outfile, "\nEliminating");
            fprint_instr(s->tac);
          }
          
          if (s->prev)              /* Renovate the statement list */
            s->prev->next = s->next;
          else
            b->sl = s->next;
          if (s->next)
            s->next->prev = s->prev;
          
          /* Renovate the TAC list */
          
          s->tac->prev->next = s->tac->next;
          s->tac->next->prev = s->tac->prev;
          
          free((void *) s->tac);    /* Abandon lost statement :( */
          free((void *) s);
        }
        helpful = b->change = TRUE;
      }
    }
  }
  while (b->next1 != MAX_BLOCKS);
}


void copy_prop_search(unsigned char n, TAC *t2, int i, int prhead) {
  
  /*
   *  Search recursively for the copy variable in t2, propagating when found.
   *  When done with this block, call the next blocks as appropriate.
   */
  
  BB *b;
  TAC *t1;
  SLIST *s;
  
  /*
   *  If the basic block list index is out of range or if this block has
   *  already been visited, then exit.
   */
  
  if (n < MAX_BLOCKS && !bbl[n]->n) {
    b = bbl[n];
    b->n = TRUE;                    /* Mark block as visited */
    
    /* If definition i may not reach this block, don't do any propagations */
    
    if (b->prev1 < MAX_BLOCKS && !(bbl[b->prev1]->DO & 1 << i) ||
        b->prev2 < MAX_BLOCKS && !(bbl[b->prev2]->DO & 1 << i))
      return;
    
    /* Search for the copy variable in block statments */
    
    for (s = b->sl; s; s = s->next) {
      t1 = s->tac;
      
      /*
       *  Break if either copy statement variable is changed;  ARG and
       *  RETURN do not change their argument -- we are assuming single
       *  functions, and thus the only calls will be to the non-destructive
       *  PRINT routines in the library.  It is likeley that RETURN will not
       *  be used in a single function, but we leave it in for convenience.
       */
      
      if ((t1->VA == t2->VA || t1->VA == t2->VB) &&
          !(t1->op == TAC_ARG || t1->op == TAC_RETURN) &&
          !(t1->op == TAC_COPY && t1->VA == t1->VB))
        return;
      
      if (t1->VA == t2->VA && (t1->op == TAC_ARG || t1->op == TAC_RETURN) ||
          t1->VB == t2->VA || t1->VC == t2->VA) {
        
        /* Propagate the copy */
        
        if (outfile) {
          if (prhead) {
            fprintf(outfile, "\nEliminating copy propagation:");
            fprint_instr(t2);
            prhead = FALSE;
          }
          fprintf(outfile, "\n");
          fprint_instr(t1);
          fprintf(outfile, "     v\n");
        }
        
        if (t1->VA == t2->VA && (t1->op == TAC_ARG || t1->op == TAC_RETURN))
          t1->VA = t2->VB;
        if (t1->VB == t2->VA)
          t1->VB = t2->VB;
        if (t1->VC == t2->VA)
          t1->VC = t2->VB;
        helpful = b->change = TRUE;
        if (outfile)
          fprint_instr(t1);
        if (peephole(t1) && outfile) {
          fprintf(outfile, "   =\n");
          fprint_instr(t1);
        }
      }
    }
    
    switch (b->type) {
    case B_END:
      break;
    case B_IF:
      copy_prop_search(b->next2, t2, i, prhead);
    default:
      copy_prop_search(b->next1, t2, i, prhead);
    }
  }
}


void sub_expr_search(unsigned char n, TAC *t2, int i, int prhead) {
  
  /*
   *  Search recursively for the common sub-expression in t2, eliminating when
   *  found.  When done with this block, call the next blocks as appropriate.
   */
  
  BB *b;
  TAC *t1;
  SLIST *s;
    
  /*
   *  If the basic block list index is out of range or if this block has
   *  already been visited, then exit.
   */
  
  if (n < MAX_BLOCKS && !bbl[n]->n) {
    b = bbl[n];
    b->n = TRUE;                    /* Mark block as visited */
    
    /* If definition i may not reach this block, don't eliminate sub-exps */
    
    if (b->prev1 < MAX_BLOCKS && !(bbl[b->prev1]->DO & 1 << i) ||
        b->prev2 < MAX_BLOCKS && !(bbl[b->prev2]->DO & 1 << i))
      return;
    
    /* Search for the sub-expression in block statements */
    
    for (s = b->sl; s; s = s->next) {
      t1 = s->tac;
      
      /* Return if any expression statement variable is changed */
      
      if (t1->VA == t2->VA || t1->VA == t2->VB || t1->VA == t2->VC)
        return;
      
      if (t1->op == t2->op && t1->VB == t2->VB && t1->VC == t2->VC) {
        
        /* Eliminate common sub-expression */
        
        if (outfile) {
          if (prhead) {
            fprintf(outfile, "\nEliminating common sub-expression:");
            fprint_instr(t2);
            prhead = FALSE;
          }
          fprintf(outfile, "\n");
          fprint_instr(t1);
          fprintf(outfile, "     v\n");
        }
        
        t1->op = TAC_COPY;
        t1->VB = t2->VA;
        t1->VC = NULL;
        helpful = b->change = TRUE;
        if (outfile)
          fprint_instr(t1);
        if (peephole(t1) && outfile) {
          fprintf(outfile, " =\n");
          fprint_instr(t1);
        }
      }
    }
    
    switch (b->type) {
    case B_END:
      break;
    case B_IF:
      sub_expr_search(b->next2, t2, i, prhead);
    default:
      sub_expr_search(b->next1, t2, i, prhead);
    }
  }
}


int use_search(unsigned char n, SYMB *v, int i) {
  
  /* Search recursively for any uses of definition; return TRUE if used */
  
  BB *b;
  SLIST *s;
    
  /*
   *  If the basic block list index is out of range or if this block has
   *  already been visited, then exit.
   */
  
  if (n < MAX_BLOCKS && !bbl[n]->n) {
    b = bbl[n];
    b->n = TRUE;                    /* Mark block as visited */
    
    /*
     *  Search for uses of the definition result; quit if definition is not
     *  "live" at the start of a statement.
     */
    
    for (s = b->sl; s; s = s->next) {
      
      if (!(s->DI & 1 << i))        /* Definition has been killed; exit */
        return FALSE;
      
      if (s->tac->VB == v || s->tac->VC == v ||
          s->tac->VA == v && (s->tac->op == 10 || s->tac->op == 12))
        return TRUE;
    }
    
    /* If we reach here, it's not been used or killed -- search on */
    
    switch (b->type) {
    case B_END:
      return FALSE;
    case B_IF:
      return (use_search(b->next1, v, i) | use_search(b->next2, v, i));
    default:
      return use_search(b->next1, v, i);
    }
  }
  else
    return FALSE;
}


void unvisit_all() {
  
  /* Mark all blocks as unvisited */
  
  int p;
  
  p = 0;
  do
    bbl[p]->n = FALSE;
  while (bbl[p++]->next1 != MAX_BLOCKS);
}


int peephole(TAC *t) {
  
  /* Perform peephole optimizations.  Most are mathematical identities */
  
  int didit = FALSE;                /* Boolean to remember sort success */
  
  didit = sort_cmtv(t);
  
  if (const_fold(t))
    return TRUE;
  
  switch (t->op) {
    
  case TAC_ADD:
    
    if ((t->VC->type == T_INT) && (t->VC->VAL1 == 0)) {     /* a + 0 = a */
      t->op = TAC_COPY;
      return TRUE;
    }
    
    break;
    
  case TAC_SUB:
    
    if ((t->VB->type == T_INT) && (t->VB->VAL1 == 0)) {     /* 0 - a = -a */
      t->VB = t->VC;
      t->VC = NULL;
      t->op = TAC_NEG;
      return TRUE;
    }
    
    if ((t->VC->type == T_INT) && (t->VC->VAL1 == 0)) {     /* a - 0 = a */
      t->op = TAC_COPY;
      return TRUE;
    }
    
    break;
    
  case TAC_MUL:
    
    if (t->VC->type == T_INT) {
      if (t->VC->VAL1 == 0) {                               /* a * 0 = 0 */
        t->VB = t->VC;
        t->VC = NULL;
        t->op = TAC_COPY;
        return TRUE;
      }
      if (t->VC->VAL1 == 1) {                               /* a * 1 = a */
        t->op = TAC_COPY;
        return TRUE;
      }
      if (t->VC->VAL1 == 2) {                               /* a * 2 = a + a */
        t->VC = t->VB;
        t->op = TAC_ADD;
        return TRUE;
      }
    }
    
    break;
    
  case TAC_DIV:
    
    if ((t->VB->type == T_INT) && (t->VB->VAL1 == 0)) {     /* 0 / a = 0 */
      t->op = TAC_COPY;
      t->VC = NULL;
      return TRUE;
    }
    
    if ((t->VC->type == T_INT) && (t->VC->VAL1 == 1)) {     /* a / 1 = a */
      t->op = TAC_COPY;
      t->VC = NULL;
      return TRUE;
    }
  }
  
  return didit;                     /* Return false if nothing was done */
}


int sort_cmtv(TAC *t) {
  
  /*
   *  If a statement is a commutative binary operation, make sure the arguments
   *  are alphabetized or ordered with variables first, constants second.
   */
  
  SYMB *s;                          /* Swapping symbol */
  
  if ((t->op == TAC_ADD) || (t->op == TAC_MUL)) {
    if ((t->VB->type == T_VAR) && (t->VC->type == T_VAR)) {
      if (strcmp(t->VB->TEXT1, t->VC->TEXT1) > 0) {
        s = t->VB;
        t->VB = t->VC;
        t->VC = s;
        return TRUE;
      }
    }
    else if (t->VB->type == T_INT && t->VC->type == T_VAR) {
      s = t->VB;
      t->VB = t->VC;
      t->VC = s;
      return TRUE;
    }
  }
  return FALSE;
}


int const_fold(TAC *t) {
  
  /* Perform constant folding if appropriate */
  
  int newc;                         /* Holds the new constant value */
  
  if ((t->op >= TAC_ADD && t->op <= TAC_DIV &&
       t->VB->type == T_INT && t->VC->type == T_INT) ||
      (t->op == TAC_NEG && t->VB->type == T_INT)) {
    
    switch (t->op) {
    case TAC_ADD:
      newc = t->VB->VAL1 + t->VC->VAL1;
      break;
    case TAC_SUB:
      newc = t->VB->VAL1 - t->VC->VAL1;
      break;
    case TAC_MUL:
      newc = t->VB->VAL1 * t->VC->VAL1;
      break;
    case TAC_DIV:
      if (t->VC->VAL1 == 0) {
        
        /*
         *  In case of division by zero, it is the user's fault.  Signal the
         *  error and set the new constant = 2^32 - 1 -- near infinity.
         */
        
        error("Division by zero encountered during optimization");
        newc = ~0;
      }
      else
        newc = t->VB->VAL1 / t->VC->VAL1;
      break;
    case TAC_NEG:
      newc = -t->VB->VAL1;
    }
    
    t->op = TAC_COPY;
    t->VB = mkconst(newc);
    t->VC = NULL;
    return TRUE;
  }
  
  else
    return FALSE;
}


unsigned char find_dest(unsigned char label) {
  
  /* Find the block that begins with the indicated label */
  
  unsigned char   dest;
  TAC            *t;
  
  for (dest = 0; dest < MAX_BLOCKS; dest++) {
    t = bbl[dest]->sl->tac;
    if (t->op == TAC_LABEL && t->VA->VAL1 == label)
      return dest;
  }
}


long kill_all(SYMB *s) {
  
  /* Find all defs that define s; return a vector that flags these defs */
  
  int d;
  long v = 0;
  
  for (d = 0; d < LL; d++) {
    if (defs[d] && defs[d]->tac->VA == s)
      v |= 1 << d;
  }
  
  return v;
}


void fprint_instr(TAC *i) {
  
  /* Print a tac instruction to the trace file.  Adapted from main.c, JPB */
  
  char sa[12];
  char sb[12];
  char sc[12];
  
  fprintf(outfile, "  ");
  
  switch(i->op) {
    case TAC_UNDEF:
      fprintf(outfile, "undef\n");
      break;
    case TAC_ADD:
      fprintf(outfile, "%s := %s + %s\n", ts(i->VA, sa), ts(i->VB, sb),
              ts(i->VC, sc));
      break;
    case TAC_SUB:
      fprintf(outfile, "%s := %s - %s\n", ts(i->VA, sa), ts(i->VB, sb),
              ts(i->VC, sc));
      break;
    case TAC_MUL:
      fprintf(outfile, "%s := %s * %s\n", ts(i->VA, sa), ts(i->VB, sb),
              ts(i->VC, sc));
      break;
    case TAC_DIV:
      fprintf(outfile, "%s := %s / %s\n", ts(i->VA, sa), ts(i->VB, sb),
              ts(i->VC, sc));
      break;
    case TAC_NEG:
      fprintf(outfile, "%s := - %s\n", ts(i->VA, sa), ts(i->VB, sb));
      break;
    case TAC_COPY:
      fprintf(outfile, "%s := %s\n", ts(i->VA, sa), ts(i->VB, sb));
      break;
    case TAC_GOTO:
      fprintf(outfile, "goto L%d\n", i->LA->VA->VAL1);
      break;
    case TAC_IFZ:
      fprintf(outfile, "ifz %s goto L%d\n", ts(i->VB, sb), i->LA->VA->VAL1);
      break;
    case TAC_IFNZ:
      fprintf(outfile, "ifnz %s goto L%d\n", ts(i->VB, sb), i->LA->VA->VAL1);
      break;
    case TAC_ARG:
      fprintf(outfile, "arg %s\n", ts(i->VA, sa));
      break;
    case TAC_CALL:
      if(i->VA == NULL)
        fprintf(outfile, "call L%d\n", i->LB->VA->VAL1);
      else
        fprintf(outfile, "%s = call L%d\n", ts(i->VA, sa), i->LB->VA->VAL1);
      break;
    case TAC_RETURN:
      fprintf(outfile, "return %s\n", ts(i->VA, sa));
      break;
    case TAC_LABEL:
      fprintf(outfile, "label L%d\n", i->VA->VAL1);
      break;
    case TAC_VAR:
      fprintf(outfile, "var %s\n", ts(i->VA, sa));
      break;
    case TAC_BEGINFUNC:
      fprintf(outfile, "beginfunc\n");
      break;
    case TAC_ENDFUNC:
      fprintf(outfile, "endfunc\n");
      break;
    default:
      
      /* Don't know what this one is */
      
      error("unknown TAC opcode");
      fprintf(outfile, "unknown %d\n", i->op);
      break;
    }
}


void data_out(DATA d) {
  
  /* Print data-flow analysis results; space each nibble for readability */
  
  int i;
  
  fprintf(outfile, "   in\t=");
  for (i = 0; i < LL; i++) {
    if (!(i & 3))
      fprintf(outfile, " ");
    fprintf(outfile, "%d", (d.in & 1 << i) >> i);
  }
  fprintf(outfile, "\n");
  
  fprintf(outfile, "   gen\t=");
  for (i = 0; i < LL; i++) {
    if (!(i & 3))
      fprintf(outfile, " ");
    fprintf(outfile, "%d", (d.gen & 1 << i) >> i);
  }
  fprintf(outfile, "\n");
  
  fprintf(outfile, "   kill\t=");
  for (i = 0; i < LL; i++) {
    if (!(i & 3))
      fprintf(outfile, " ");
    fprintf(outfile, "%d", (d.kill & 1 << i) >> i);
  }
  fprintf(outfile, "\n");
  
  fprintf(outfile, "   out\t=");
  for (i = 0; i < LL; i++) {
    if (!(i & 3))
      fprintf(outfile, " ");
    fprintf(outfile, "%d", (d.out & 1 << i) >> i);
  }
  fprintf(outfile, "\n");
}
//E*O*F optimize.c//

echo x - parser.y
mv parser.y parser.y.old
cat > "parser.y" << '//E*O*F parser.y//'
/******************************************************************************
*******************************************************************************


          PPPPPPP     AAAA    RRRRRRR    SSSSSS   EEEEEEEE  RRRRRRR 
          PPPPPPPP   AAAAAA   RRRRRRRR  SSSSSSSS  EEEEEEEE  RRRRRRRR
          PP    PP  AA    AA  RR    RR  SS        EE        RR    RR
          PPPPPPP   AAAAAAAA  RRRRRRRR  SSSSSSS   EEEEEE    RRRRRRRR
          PP        AA    AA  RRRRRRR         SS  EE        RRRRRRR 
          PP        AA    AA  RR  RR          SS  EE        RR  RR  
          PP        AA    AA  RR   RR   SSSSSSSS  EEEEEEEE  RR   RR 
          PP        AA    AA  RR    RR   SSSSSS   EEEEEEEE  RR    RR


*******************************************************************************
*******************************************************************************

			      A Compiler for VSL
			      ==================

   This is the YACC parser. It creates a tree representation of the program for
   subsequent conversion to TAC.

   Modifications:
   ==============

   16 Nov 88 JPB:  First version
   26 Apr 89 JPB:  Version for publication
   27 Jul 89 JPB:  Final version for publication

*******************************************************************************
******************************************************************************/

%{

/* We include the standard headers, but not "parser.h", since that will be
   produced by YACC when the YACC program is translated. */

#include <stdio.h>
#include <ctype.h>
#include "vc.h"

/* These are the prototypes of routines defined and used in the parser */

TAC   *do_program( TAC *c ) ;
TAC   *do_func( SYMB *func,
	      TAC  *args,
	      TAC  *code ) ;
TAC   *declare_var( SYMB *var ) ;
TAC   *do_assign( SYMB  *var,
		ENODE *expr ) ;
ENODE *do_bin(  int    binop,
		ENODE *expr1,
		ENODE *expr2 ) ;
ENODE *do_un(  int    unop,
	       ENODE *expr ) ;
ENODE *do_fnap( SYMB  *func,
		ENODE *arglist ) ;
TAC   *do_lib( int   rtn,
	     SYMB *arg ) ;
TAC   *do_if( ENODE *expr,
	    TAC   *stmt ) ;
TAC   *do_test( ENODE *expr,
	      TAC   *stmt1,
	      TAC   *stmt2 ) ;
TAC   *do_while( ENODE *expr,
	       TAC   *stmt ) ;
ENODE *mkenode( ENODE *next,
		SYMB  *res,
		TAC   *code ) ;
void  yyerror( char *str ) ;

%}

/* %union defines the type of attribute to be synthesised by the semantic
   actions. The variables, constants and text produced by the lexical analyser
   will be symbol table nodes. Most YACC rules will produce lists of TAC,
   however those involving expressions will need to use "enode's" to specify
   where the result of the TAC is put. */

%union
{
	SYMB   *symb ;		 /* For vars, consts and text */
	TAC    *tac ;		 /* For most things */
	ENODE  *enode ;		 /* For expressions */
}

/* Tokens. Most of these don't need types, since they have no associated
   attribute. However variables, integers and text have to have a more complex
   structure, since they return symbol table nodes as attributes. */

%token         FUNC			 /* 'FUNC' */
%token <symb>  VARIABLE			 /* variable name */
%token         ASSIGN_SYMBOL		 /* ':=' */
%token <symb>  INTEGER			 /* integer number */
%token         PRINT			 /* 'PRINT' */
%token <symb>  TEXT			 /* quoted text */
%token         RETURN			 /* 'RETURN' */
%token         CONTINUE			 /* 'CONTINUE */
%token         IF			 /* 'IF' */
%token         THEN			 /* 'THEN' */
%token         ELSE			 /* 'ELSE' */
%token         FI			 /* 'FI' */
%token         WHILE			 /* 'WHILE' */
%token         DO			 /* 'DO' */
%token         DONE			 /* 'DONE' */
%token         VAR			 /* 'VAR' */
%token         UMINUS			 /* used for precedence */

/* Now type declarations for the non-terminals. Most non-terminals just return
   a list of TAC as result, however expressions also return a pointer to the
   symbol holding the result of the calculation. */

%type <tac>     program
%type <tac>     function_list
%type <tac>     function
%type <tac>     parameter_list
%type <tac>     variable_list
%type <enode>   argument_list
%type <enode>   expression_list
%type <tac>     statement
%type <tac>     assignment_statement
%type <enode>   expression
%type <tac>     print_statement
%type <tac>     print_list
%type <tac>     print_item
%type <tac>     return_statement
%type <tac>     null_statement
%type <tac>     if_statement
%type <tac>     while_statement
%type <tac>     block
%type <tac>     declaration_list
%type <tac>     declaration
%type <tac>     statement_list
%type <tac>     error

/* We define the precedence of the arithmetic operators, including a
   pseudo-token, "UMINUS" to be used for unary minus when it occurs in
   expressions. */

%left  '+' '-'
%left  '*' '/'
%right UMINUS

%%

/* These are the grammar rules. "program" is the sentence symbol of the
   grammar. It uses the default action $$ = $1 ; to pass back the TAC
   constructed. */

program			:	function_list
			;

/* "function_list" is typical of may rules with two parts. Where we have a
   "function_list" followed by a "function" we call "join_tac()" to combine the
   code for each into one. Note that this use of "join_tac()", involving a walk
   down one of the code lists is very inefficient if the code gets at all
   large. If we intend using VSL for major programs (admittedly unlikely), then
   we should wish to avoid this each time we joined code. We should probably
   chose to use a non-linked TAC representation and place markers as discussed
   in chapter 6. */

function_list		:	function
			|	function_list function
				{
					$$ = join_tac( $1, $2 ) ;
				}
			;

/* Note that when we start a new "function" we are able to set the temporary
   variable count back to zero, since temporary variable names need only be
   unique within the function where they are declared. Like most rules we call
   a subsidiary routine, "do_func()", to build the code.

   This is one of the places where we attempt rudimentary error recovery. We do
   not specify a synchronising set, but let the parser recover for itself. */

function		:	FUNC VARIABLE '(' parameter_list ')'
			        statement
				{
					next_tmp = 0 ;
					$$ = do_func( $2, $4, $6 ) ;
				}
			|	error
				{
					error( "Bad function syntax" ) ;
					$$ = NULL ;
				}
			;

parameter_list		:	variable_list
			|
				{
					$$ = NULL ;
				}
			;

variable_list		:	VARIABLE
				{
					$$ = declare_var( $1 ) ;
				}		
			|	variable_list ',' VARIABLE
				{
					TAC *t = declare_var( $3 ) ;

					t->prev = $1 ;
					$$ = t ;
				}		
			;

statement		:	assignment_statement
			|	return_statement
			|	print_statement
			|	null_statement
			|	if_statement
			|	while_statement
			|	block
			|   	error
				{
					error( "Bad statement syntax" ) ;
					$$ = NULL ;
				}
			;

assignment_statement	:	VARIABLE ASSIGN_SYMBOL expression
				{

					$$ = do_assign( $1, $3 ) ;
				}
			;

/* Rules for expressions. Note the use of "%prec UMINUS" to define the higher
   precedence of negation. */

expression		:	expression '+' expression
				{
					$$ = do_bin( TAC_ADD, $1, $3 ) ;
				}
			|	expression '-' expression
				{
					$$ = do_bin( TAC_SUB, $1, $3 ) ;
				}
			|	expression '*' expression
				{
					$$ = do_bin( TAC_MUL, $1, $3 ) ;
				}
			|	expression '/' expression
				{
					$$ = do_bin( TAC_DIV, $1, $3 ) ;
				}
			|	'-' expression  %prec UMINUS
				{
					$$ = do_un( TAC_NEG, $2 ) ;
				}
			|	'(' expression ')'
				{
					$$ = $2 ;
				}		
			|	INTEGER
				{
					$$ = mkenode( NULL, $1, NULL ) ;
				}
			|	VARIABLE
				{
					$$ = mkenode( NULL, $1, NULL ) ;
				}
			|	VARIABLE '(' argument_list ')'
				{
					$$ = do_fnap( $1, $3 ) ;
				}		
			|   	error
				{
					error( "Bad expression syntax" ) ;
					$$ = mkenode( NULL, NULL, NULL ) ;
				}
			;

argument_list		:
				{
					$$ = NULL ;
				}
			|	expression_list
			;

expression_list		:	expression
			|	expression_list ',' expression
				{

					/* Construct a list of expr nodes */

					$1->next = $3 ;
					$$       = $1 ;
				}
			;

print_statement		:	PRINT print_list
				{
					$$ = $2 ;
				}		
			;

print_list		:	print_item
			|	print_list ',' print_item
				{
					$$ = join_tac( $1, $3 ) ;
				}		
			;

/* PRINT items are handled by calls to library routines. These take as their
   argument the libary routine to call and the symbol to pass as argument. */

print_item		:	expression
				{

					/* Call printn library routine */

					$$ = join_tac( $1->tac,
						       do_lib( LIB_PRINTN,
						       $1->res )) ;
				}
			|	TEXT
				{

					/* Call prints, passing the address of
					   the string */

					$$ = do_lib( LIB_PRINTS, $1 ) ;
				}
			;

return_statement	:	RETURN expression
				{
					TAC *t = mktac( TAC_RETURN, $2->res,
							NULL, NULL ) ;
					t->prev = $2->tac ;
					free_enode( $2 ) ;
					$$      = t ;
				}		
			;

null_statement		:	CONTINUE
				{
					$$ = NULL ;
				}		
			;

/* Note the use of two different routines to handle the different types of IF
   statement. We could have shared this code for conciseness. */

if_statement		:	IF expression THEN statement FI
				{
					$$ = do_if( $2, $4 ) ;
				}
			|	IF expression THEN statement
			        ELSE statement FI
				{
					$$ = do_test( $2, $4, $6 ) ;
				}
			;

while_statement		:	WHILE expression DO statement DONE
				{
					$$ = do_while( $2, $4 ) ;
				}		
			;

block			:	'{' declaration_list statement_list '}'
				{
					$$ = join_tac( $2, $3 ) ;
				}		
			;

declaration_list	:
				{
					$$ = NULL ;
				}
			|	declaration_list declaration
				{
					$$ = join_tac( $1, $2 ) ;
				}
			;

declaration		:	VAR variable_list
				{
					$$ = $2 ;
				}
			;

statement_list		:	statement

			|	statement_list statement
				{
					$$ = join_tac( $1, $2 ) ;
				}		
			;

%%

/* These are the routines to support the various YACC rules. It is invariably
   clearer to put anything but the simplest semantic action in a routine,
   because the layout of YACC bunches code to the right so much. */


TAC *do_func( SYMB *func,	 		 /* Function */
	      TAC  *args,	 		 /* Its args */
	      TAC  *code )	 		 /* Its code */

/* For a function we must add TAC_BEGINFUNC and TAC_ENDFUNC quadruples
   around it, and a new label at the start. We then enter the name of the
   function in the symbol table. It should not have been declared as a variable
   or function elsewhere, and so should still have type T_UNDEF.

   The function may already be the subject of function calls. The address of
   the quadruples for these calls are held in the LABEL2 field of its symbol
   table entry, ready for backpatching. We run down this list backpatching in
   the address of the starting label, and then replace the field with the
   address of the starting label, also updating the type to T_FUNC.

   Note that there is a fault in the compiler at this point. If we never
   declare a function that is used, then its address will never be backpatched.
   This is a semantic check that needs to be added at the end of parsing. */

{
	TAC *tlist ;			 /* The backpatch list */

	TAC *tlab ;			 /* Label at start of function */
	TAC *tbegin ;			 /* BEGINFUNC marker */
	TAC *tend ;			 /* ENDFUNC marker */

	/* Add this function to the symbol table. If its already there its been
	   used before, so backpatch the address into the call opcodes. If
	   declared already we have a semantic error and give up. Otherwise
	   patch in the addresses and declare as a function */

	if( func->type != T_UNDEF )
	{
		error( "function already declared" ) ;
		return NULL ;
	}

	tlab   = mktac( TAC_LABEL,     mklabel( next_label++ ), NULL, NULL ) ;
	tbegin = mktac( TAC_BEGINFUNC, NULL, NULL, NULL ) ;
	tend   = mktac( TAC_ENDFUNC,   NULL, NULL, NULL ) ;

	tbegin->prev = tlab ;
	code         = join_tac( args, code ) ;
	tend->prev   = join_tac( tbegin, code ) ;

	tlist = func->LABEL2 ;			 /* List of addresses if any */

	while( tlist != NULL )
	{
		TAC *tnext = tlist->LB ;  	 /* Next on list */

		tlist->LB  = tlab ;
		tlist      = tnext ;
	}

	func->type   = T_FUNC ;		 /* And declare as func */
	func->LABEL2 = tlab ;

	return tend ;

}	/* TAC *do_func( SYMB *func,
		     	 TAC  *args,
			 TAC  *code ) */


TAC *declare_var( SYMB *var )

/* All variable names may be used only once throughout a program. We check here
   that they have not yet been declared and if so declare them, setting their
   stack offset to -1 (an invalid offset) and marking their address descriptor
   empty. Note that this is a fault in the compiler. We really do need to mark
   the beginning and end of blocks in which variables are declared, so that
   scope can be checked. */

{
	if( var->type != T_UNDEF )
	{
		error( "variable already declared" ) ;
		return NULL ;
	}

	var->type  = T_VAR ;
	var->ADDR2 = -1 ;		 /* Unset address */

	/* TAC for a declaration */

	return  mktac( TAC_VAR, var, NULL, NULL ) ;

}	/* TAC *declare_var( SYMB *var ) */


TAC *do_assign( SYMB  *var,	 /* Variable to be assigned */
		ENODE *expr )	 /* Expression to assign */

/* An assignment statement shows the use of expression nodes. We construct a
   copy node to take the result of the expression and copy it into the
   variable, having performed suitable semantic checks. Note that if we
   discover that the variable has not been declared, we declare it, to prevent
   further non-declaration errors each time it is referenced. */

{
	TAC  *code ;

	/* Warn if variable not declared, then build code */

	if( var->type != T_VAR )
		error( "assignment to non-variable" ) ;

	code       = mktac( TAC_COPY, var, expr->res, NULL ) ;
	code->prev = expr->tac ;
	free_enode( expr ) ;		 /* Expression now finished with */

	return code ;

}	/* TAC *do_assign( SYMB  *var,
			   ENODE *expr ) */


ENODE *do_bin(  int    binop,		 /* TAC binary operator */
		ENODE *expr1,		 /* Expressions to operate on */
		ENODE *expr2 )

/* We then have the first of the arithmetic routines to handles binary
   operators.  We carry out one of the few optimisations in the compiler here,
   constant folding, reusing the expression node for efficiency. If we can't do
   folding we generate the result into a temporary variable, which we first
   declare, returning an expression node for the TAC with the temporary in the
   result field. */

{
	TAC  *temp ;			 /* TAC code for temp symbol */
	TAC  *res ;			 /* TAC code for result */

        if(( binop == TAC_DIV ) && ( expr2->EVAL1 == 0))
                error( "division by zero" ); /* Division by zero! */

	/* Do constant folding if possible. Calculate the constant into expr1
	   and free up expr2. */

	if(( expr1->ETYPE == T_INT ) && ( expr2->ETYPE == T_INT ))
	{
		switch( binop )		 /* Chose the operator */
		{
		case TAC_ADD:

			expr1->EVAL1 = expr1->EVAL1 + expr2->EVAL1 ;
			break ;

		case TAC_SUB:

			expr1->EVAL1 = expr1->EVAL1 - expr2->EVAL1 ;
			break ;

		case TAC_MUL:

			expr1->EVAL1 = expr1->EVAL1 * expr2->EVAL1 ;
			break ;

		case TAC_DIV:

			expr1->EVAL1 = expr1->EVAL1 / expr2->EVAL1 ;
			break ;
		}

		free_symb( expr2->res ) ;  /* Release space in expr2 */
		free_enode( expr2 ) ;

		return expr1 ;		   /* The new expression */
	}

	/* Not constant, so create a TAC node for a binary operator, putting
	   the result in a temporary. Bolt the code together, reusing expr1 and
	   freeing expr2. */

	temp       = mktac( TAC_VAR, mktmp(), NULL, NULL ) ;
	temp->prev = join_tac( expr1->tac, expr2->tac ) ;
	res        = mktac( binop, temp->VA, expr1->res, expr2->res ) ;
	res->prev  = temp ;

	expr1->res = temp->VA ;
	expr1->tac = res ;
	free_enode( expr2 ) ;

	return expr1 ;	

}	/* ENODE *do_bin(  int    binop,
	 		   ENODE *expr1,
			   ENODE *expr2 ) */


ENODE *do_un(  int    unop,		 /* TAC unary operator */
	       ENODE *expr )		 /* Expression to operate on */

/* This is an analagous routine to deal with unary operators. In the interests
   of generality it has been written to permit easy addition of new unary
   operators, although there is only one at present. */


{
	TAC  *temp ;			 /* TAC code for temp symbol */
	TAC  *res ;			 /* TAC code for result */

	/* Do constant folding if possible. Calculate the constant into expr */

	if( expr->ETYPE == T_INT )
	{
		switch( unop )		 /* Chose the operator */
		{
		case TAC_NEG:

			expr->EVAL1 = - expr->EVAL1 ;
			break ;
		}

		return expr ;		   /* The new expression */
	}

	/* Not constant, so create a TAC node for a unary operator, putting
	   the result in a temporary. Bolt the code together, reusing expr. */

	temp       = mktac( TAC_VAR, mktmp(), NULL, NULL ) ;
	temp->prev = expr->tac ;
	res        = mktac( unop, temp->VA, NULL, expr->res ) ;
	res->prev  = temp ;

	expr->res = temp->VA ;
	expr->tac = res ;

	return expr ;	

}	/* ENODE *do_un(  int    unop,
	 		  ENODE *expr ) */


ENODE *do_fnap( SYMB  *func,		 /* Function to call */
		ENODE *arglist )	 /* Its argument list */

/* Construct a function call to the given function. If the function is not yet
   defined, then we must add this call to the backpatching list. Return the
   result of the function in a temporary. Note the qualication about
   backpatching above in the definition of "do_func()"

   When constructing a function call we put the result in a temporary. We join
   all the TAC for the expressions first, then join the code for the TAC_ARG
   instructions, since arg instructions must appear consecutively. */

{
	ENODE  *alt ;			 /* For counting args */
	SYMB   *res ;			 /* Where function result will go */
	TAC    *code ;			 /* Resulting code */
	TAC    *temp ;			 /* Temporary for building code */

	/* Check that this is a valid function. In this case it must either be
	   T_UNDEF or T_FUNC. If it is declare the result, run down the
	   argument list, joining up the code for each argument, then generate
	   a sequence of arg instructions and finally a call instruction */

	if(( func->type != T_UNDEF ) && ( func->type != T_FUNC ))
	{
		error( "function declared other than function" );
		return NULL ;
	}

	res   = mktmp() ;		             /* For the result */
	code  = mktac( TAC_VAR, res, NULL, NULL ) ;

	for( alt = arglist ; alt != NULL ; alt = alt->next )  /* Join args */
		code = join_tac( code, alt->tac ) ;

	while( arglist != NULL )	 /* Generate ARG instructions */
	{
		temp       = mktac( TAC_ARG, arglist->res, NULL, NULL ) ;
		temp->prev = code ;
		code       = temp ;

		alt = arglist->next ;
		free_enode( arglist ) ;	 /* Free the space */
		arglist = alt ;
	} ;

	temp       = mktac( TAC_CALL, res, (SYMB *)func->LABEL2, NULL ) ;
	temp->prev = code ;
	code       = temp ;

	/* If the function is undefined update its backpatching list with the
	   address of this instruction and then return an expression node for
	   the result */

	if( func->type == T_UNDEF )
		func->LABEL2 = code ;

	return mkenode( NULL, res, code ) ;

}	/* ENODE *do_fnap( SYMB  *func,
		           ENODE *arglist ) */


TAC *do_lib( int   rtn,			 /* Routine to call */
	     SYMB *arg )		 /* Argument to pass */

/* PRINT items are handled by calls to library routines. These take as their
   argument the libary routine to call and the symbol to pass as argument.
   This routine constructs a call to a libary routine with a single argument.
*/

{
	TAC *a = mktac( TAC_ARG, arg, NULL, NULL ) ;
	TAC *c = mktac( TAC_CALL, NULL, (SYMB *)library[rtn], NULL ) ;

	c->prev = a ;

	return c ;

}	/* TAC *do_lib( int   rtn,
	   		SYMB *arg ) */


TAC *do_if( ENODE *expr,		 /* Condition */
	    TAC   *stmt )		 /* Statement to execute */

/* For convenience we have two routines to handle IF statements, "do_if()"
   where there is no ELSE part and "do_test()" where there is. We always
   allocate TAC_LABEL instructions, so that the destinations of all branches
   will appear as labels in the resulting TAC code. */

{
	TAC *label = mktac( TAC_LABEL, mklabel( next_label++ ), NULL, NULL ) ;
	TAC *code  = mktac( TAC_IFZ, (SYMB *)label, expr->res, NULL ) ;

	code->prev  = expr->tac ;
	code        = join_tac( code, stmt ) ;
	label->prev = code ;

	free_enode( expr ) ;		 /* Expression finished with */

	return label ;

}	/* TAC *do_if( ENODE *expr,
	    	       TAC   *stmt ) */


TAC *do_test( ENODE *expr,		 /* Condition */
	      TAC   *stmt1,		 /* THEN part */
	      TAC   *stmt2 )		 /* ELSE part */

/* Construct code for an if statement with else part */

{
	TAC *label1 = mktac( TAC_LABEL, mklabel( next_label++ ), NULL, NULL ) ;
	TAC *label2 = mktac( TAC_LABEL, mklabel( next_label++ ), NULL, NULL ) ;
	TAC *code1  = mktac( TAC_IFZ, (SYMB *)label1, expr->res, NULL ) ;
	TAC *code2  = mktac( TAC_GOTO, (SYMB *)label2, NULL, NULL ) ;

	code1->prev  = expr->tac ;		        /* Join the code */
	code1        = join_tac( code1, stmt1 ) ;
	code2->prev  = code1 ;
	label1->prev = code2 ;
	label1       = join_tac( label1, stmt2 ) ;
	label2->prev = label1 ;

	free_enode( expr ) ;		 /* Free the expression */

	return label2 ;

}	/* TAC *do_test( ENODE *expr,
	      		 TAC   *stmt1,
	      		 TAC   *stmt2 ) */


TAC *do_while( ENODE *expr,		 /* Condition */
	       TAC   *stmt )		 /* Body of loop */

/* Do a WHILE loop. This is the same as an IF statement with a jump back at the
   end. We bolt a goto on the end of the statement, call do_if to construct the
   code and join the start label right at the beginning */

{
	TAC *label = mktac( TAC_LABEL, mklabel( next_label++ ), NULL, NULL ) ;
	TAC *code  = mktac( TAC_GOTO, (SYMB *)label, NULL, NULL ) ;

	code->prev = stmt ;		 /* Bolt on the goto */

	return join_tac( label, do_if( expr, code )) ;

}	/* TAC *do_while( ENODE *expr,
	       		  TAC   *stmt ) */


ENODE *mkenode( ENODE *next,
		SYMB  *res,
		TAC   *code )

/* The routine to make an expression node. We put this here rather than with
   the other utilities in "main.c", since it is only used in the parser. */

{
	ENODE *expr = get_enode() ;

	expr->next = next ;
	expr->res  = res ;
	expr->tac  = code ;

	return expr ;

}	/* ENODE *mkenode( ENODE *next,
			   SYMB  *res,
			   TAC   *code ) */


void  yyerror( char *str )

/* The Yacc default error handler. This just calls our error handler */

{
	error( str ) ;

}	/* void  yyerror( char *str ) */
//E*O*F parser.y//

echo x - scanner.l
mv scanner.l scanner.l.old
cat > "scanner.l" << '//E*O*F scanner.l//'
%{
/******************************************************************************
*******************************************************************************


      SSSSSS     CCCCC     AAAA    NN    NN  NN    NN  EEEEEEEE  RRRRRRR 
     SSSSSSSS   CCCCCCC   AAAAAA   NNN   NN  NNN   NN  EEEEEEEE  RRRRRRRR
     SS        CC        AA    AA  NNNN  NN  NNNN  NN  EE        RR    RR
     SSSSSSS   CC        AAAAAAAA  NN NN NN  NN NN NN  EEEEEE    RRRRRRRR
           SS  CC        AA    AA  NN  NNNN  NN  NNNN  EE        RRRRRRR 
           SS  CC        AA    AA  NN  NNNN  NN  NNNN  EE        RR  RR  
     SSSSSSSS   CCCCCCC  AA    AA  NN   NNN  NN   NNN  EEEEEEEE  RR   RR 
      SSSSSS     CCCCC   AA    AA  NN    NN  NN    NN  EEEEEEEE  RR    RR


*******************************************************************************
*******************************************************************************

			      A Compiler for VSL
			      ==================
   A scanner for VSL

   Modifications:
   ==============

   16 Nov 88 JPB:  First version
   26 Apr 89 JPB:  Simple version
   25 Jul 89 JPB:  Final version for publication

*******************************************************************************
******************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include "vc.h"
#include "parser.h"

/* Routines defined here. These are in the code section below and build symbol
   table entries for variable names, integer constants and text strings
   respectively. */ 

void  mkname( void ) ;
void  mkval( void ) ;
void  mktext( void ) ;

/* We define some useful patters using regular expressions as described in
   chapter 5. Note how earlier definitions are used later (e.g. the definition
   of "delimiter" in the definition of "whitespace". These patterns are very
   straightforward, since all VSL reserved words use upper case letters and
   variable names use only lower case. */

%}

comment		"//".*
delimiter	[ \t\n]
whitespace	{delimiter}+
uc_letter	[A-Z]
lc_letter	[a-z]
letter		{lc_letter}|{uc_letter}
ascii_char	[^\"\n]
escaped_char	\\n|\\\"
digit		[0-9]
variable	{lc_letter}({lc_letter}|{digit})*
integer		{digit}+
text		\"({ascii_char}|{escaped_char})*\"

%{
/* Now follows the rule section. We wish to return the appropriate token in
   each case. We start with rules to ignore comments (everything from // to the
   end of line) and white space. Then come the three complex lexemes,
   "variable", "integer" and "text". In each case we call "mkxxx()" to build an
   appropriate symbol table entry from "yytext" and put the result in "yylval",
   as the attribute to go back with the token.

   We then include patterns to recognise the assign symbol, ":=", and the
   reserved words.

   Anything that has not been recognised will then be picked up by the last
   match, which is for single character tokens. This will only be used if
   nothing longer can be matched. Single character variables and integers will
   not be picked up by this, even though they are the same length, because
   their rule is specified earlier. An alternative approach would be to specify
   the individual single character tokens that are permissible and return an
   "ERROR" token for any other single character. The arrangement as it stands
   leaves detection of such errors to the parser. */
%}

%%

{comment}	{ 			 /* Ignore comments */ }
{whitespace}	{ 			 /* Ignore whitespace */ }
{variable}	{ mkname() ;             /* Save the variable name */
		  return VARIABLE ;  	 /* A variable name */ }
{integer}	{ mkval() ;		 /* Save the integer value */
		  return INTEGER ;   	 /* A number */ }
{text}		{ mktext() ;		 /* Save the text string */
		  return TEXT ;      	 /* A string */ }
":="		{ return ASSIGN_SYMBOL ; /* ':=' */ }
FUNC		{ return FUNC ;      	 /* 'FUNC' */ }
PRINT		{ return PRINT ;	 /* 'PRINT' */ }
RETURN		{ return RETURN ;	 /* 'RETURN' */ }
CONTINUE	{ return CONTINUE ;	 /* 'CONTINUE' */ }
IF		{ return IF ;		 /* 'IF' */ }
THEN		{ return THEN ;		 /* 'THEN' */ }
ELSE		{ return ELSE ;		 /* 'ELSE' */ }
FI		{ return FI ;		 /* 'FI' */ }
WHILE		{ return WHILE ;	 /* 'WHILE' */ }
DO		{ return DO ;		 /* 'DO' */ }
DONE		{ return DONE ;		 /* 'DONE' */ }
VAR		{ return VAR ;		 /* 'VAR' */ }
.		{ return yytext[0] ; 	 /* Single character operator */ }

%%

/* Support code */


void  mkname( void )

/* Lookup a name in the symbol table. If not there set up a new one, returning
   the result in "yylval". Note that "yylval" is a union, defined in parser.h
   and so we must specify which member of the union (in this case "symb") we
   wish to used. We insert the name in the symbol table, but at this stage with
   type T_UNDEF, since we do not know what its type is. */

{
	struct symb *t ;		 /* Pointer to looked up symbol */
	char        *s ;		 /* Permanent text of string */

	/* If the string exists return with it in yylval */

	if((t = lookup( yytext )) != NULL )
	{
		yylval.symb = t ;
		return ;
	}

	/* Unseen before, so make a permanent copy, set up a new symbol table
	   node, insert it into the symbol table and assign it to yylval. */

	s = (char *)safe_malloc( yyleng + 1 ) ;	 /* Space for permanent copy */

	strncpy( s, yytext, yyleng ) ;
	s[yyleng] = EOS ;

	t        = get_symb() ;
	t->type  = T_UNDEF ;		 /* Don't know which node type yet */
	t->TEXT1 = s ;			 /* Text argument */

	insert( t ) ;
	yylval.symb = t ;		 /* Symbol type in union */

}	/* void  mkname( void ) */


void  mkval( void )

/* Set up a node for an integer read by the scanner. We use the library routine
   "atoi()" to convert the text of "yytext" to an integer. */

{
	yylval.symb = mkconst( atoi( yytext )) ;

}	/* void  mkval( void ) */


void  mktext( void )

/* Text is treated very similarly to a variable name. "mktext()" uses
   "mkname()" to do most of the work, and then just changes the relevant
   fields. Strings will be put out as constant data at the end of the program
   and we give it a label to mark its beginning. Note that there is no risk of
   a piece of text being mistaken for a variable name during symbol lookup,
   since the text field of a text node includes the surrounding quotes. */

{
	mkname() ;
	yylval.symb->type = T_TEXT ;
	yylval.symb->VAL2 = next_label++ ;

}	/* mktext( void ) */
//E*O*F scanner.l//

echo x - vc.h
mv vc.h vc.h.old
cat > "vc.h" << '//E*O*F vc.h//'
/******************************************************************************
*******************************************************************************


          HH    HH  EEEEEEEE    AAAA    DDDDDD    EEEEEEEE  RRRRRRR 
          HH    HH  EEEEEEEE   AAAAAA   DDDDDDD   EEEEEEEE  RRRRRRRR
          HH    HH  EE        AA    AA  DD    DD  EE        RR    RR
          HHHHHHHH  EEEEEE    AAAAAAAA  DD    DD  EEEEEE    RRRRRRRR
          HH    HH  EE        AA    AA  DD    DD  EE        RRRRRRR 
          HH    HH  EE        AA    AA  DD    DD  EE        RR  RR  
          HH    HH  EEEEEEEE  AA    AA  DDDDDDD   EEEEEEEE  RR   RR 
          HH    HH  EEEEEEEE  AA    AA  DDDDDD    EEEEEEEE  RR    RR


*******************************************************************************
*******************************************************************************

			      A Compiler for VSL
			      ==================

   This is the general header file.

   Modifications:
   ==============

   22 Nov 88 JPB:  First version
   26 Apr 89 JPB:  Version for publication
   13 Jun 90 JPB:  Now refers to library directory (noted by R C Shaw, Praxis).

*******************************************************************************
******************************************************************************/

/* We start by defining the various constants used throughout the compiler. */

#define TRUE        1			 /* Booleans */
#define FALSE       0
#define EOS         0			 /* End of string */
#define HASHSIZE  997			 /* Size of symbol table */
#define R_UNDEF    -1		 	 /* Not a valid register */

/* We define the various symbol types permitted. Note the use of T_UNDEF Many
   names are entered into the symbol table by the lexical analyser before their
   type is known, and so we given them an undefined type. */

#define  T_UNDEF  0			 /* Types for symbol table */
#define  T_VAR 	  1			 /* Local Variable */
#define  T_FUNC   2			 /* Function */
#define  T_TEXT   3			 /* Static string */
#define  T_INT    4			 /* Integer constant */
#define  T_LABEL  5			 /* TAC label */

/* We define constants for each of the three address code (TAC) instructions.
   For convenience we have an undefined instruction, then we specify the 12
   main TAC opcodes. */ 

#define  TAC_UNDEF    0		 	 /* TAC instructions */
#define  TAC_ADD      1			 /* a := b + c */
#define  TAC_SUB      2			 /* a := b - c */
#define  TAC_MUL      3			 /* a := b * c */
#define  TAC_DIV      4			 /* a := b / c */
#define  TAC_NEG      5			 /* a := -b */
#define  TAC_COPY     6			 /* a := b */
#define  TAC_GOTO     7			 /* goto a */
#define  TAC_IFZ      8			 /* ifz b goto a */
#define  TAC_IFNZ     9			 /* ifnz b goto a */
#define  TAC_ARG     10			 /* arg a */
#define  TAC_CALL    11			 /* a := call b */
#define  TAC_RETURN  12			 /* return a */

/* We then add some extra "pseudo-instructions" to mark places in the code.
   TAC_LABEL s used to mark branch targets. Its first argument will be a symbol
   table entry for a label giving a unique number for this label. TAC_VAR
   is associated with variable declarations, to help in assigning stack
   locations. TAC_BEGINFUNC and TAC_ENDFUNC mark the beginning and end of
   functions respectively. */

#define  TAC_LABEL       13		 /* Marker for LABEL a */
#define  TAC_VAR         14		 /* Marker for VAR a */
#define  TAC_BEGINFUNC   15		 /* Markers for function */
#define  TAC_ENDFUNC     16

/* The library routines are supplied in an external file. Their entry points
   are held in a table, and we define the offsets in this table here as
   LIB_PRINTN and LIB_PRINTS. At present these are the only two library
   routines, used to print out numbers and strings in PRINT statements. 

   The book assumes that the code generator library and header files are in the
   same directory as the compiler. For greater flexibility we #define a library
   directory here. This will almost certainly need changing for individual
   systems. */

#define  LIB_PRINTN     0		 /* Index into library entry points */
#define  LIB_PRINTS     1
#define  LIB_MAX        2

#define  LIB_DIR  "/usr3/cs/johnsonj/comps/"  /* Library directory */

/* Many of the structures we are to use have complex unions and subfields.
   Specifying which field we are want can be verbose and for convenience we
   define some of the subfields. Thus given a pointer to a symbol table entry,
   "sp" the "text" field of the "val1" union would be referred to as
   "sp->val1.text". Instead these #define's allow us to write "sp->TEXT1". */

#define VAL1   val1.val			 /* Value val1 */
#define TEXT1  val1.text		 /* Text val1 */
#define VAL2   val2.val			 /* Value val2 */
#define LABEL2 val2.label		 /* Label val2 */
#define ADDR2  val2.val			 /* Address val2 */
#define ETYPE  res->type		 /* Type of expr result */
#define EVAL1  res->val1.val             /* Value field in expr */
#define VA     a.var			 /* Var result in TAC */
#define LA     a.lab			 /* Label result in TAC */
#define VB     b.var			 /* Var first arg in TAC */
#define LB     b.lab			 /* Label first arg in TAC */
#define VC     c.var			 /* Var second arg in TAC */
#define LC     c.lab			 /* Label second arg in TAC */

/* This is the central structure of the compiler, the symbol table entry, SYMB.
   The symbol table takes the form of an open hash table. The entries are
   linked via the "next" field and have a "type" field. The value of this field
   determines the use made of the two value fields, which may hold text
   pointers or intgers. The whole is set up using a typedef for clarity in the
   code.

   For convenience the same structure is used for items like constants and
   labels even if they do not need to be entered into the symbol table. This
   makes for a simpler TAC data structure. */

typedef struct symb			 /* Symbol table entry */
{
	struct symb *next ;		 /* Next in chain */
	int          type ;		 /* What is this symbol */
	union				 /* Primary value */
	{
		int         val ;	 /* For integers */
		char       *text ;	 /* For var names */
	} val1 ;
	union				 /* Secondary value */
	{
		int         val ;	 /* For offsets etc */
		struct tac *label ;	 /* For branches */
	} val2 ;
} SYMB ;

/* TAC is stored as a doubly-linked list of quadruples. In general we will pass
   round pointers to the last generated quadruple in the syntax analyser and
   first generated quadruple in the code generator. The opcode is an integer
   and the argument and the result fields are either pointers to symbol table
   entries or pointers to other TAC quadruples (for branch instructions). The
   names of the fields are based on TAC instructions of the form

      a := b op c

   Again this is implemented as a typedef for convenience */

typedef struct tac			 /* TAC instruction node */
{
	struct tac  *next ;		 /* Next instruction */
	struct tac  *prev ;		 /* Previous instruction */
	int          op ;		 /* TAC instruction */
	union				 /* Result */
	{
		SYMB        *var ;	 /* Name */
		struct tac  *lab ;	 /* Address */
	} a ;
	union		 		 /* Operands */
	{
		SYMB        *var ;
		struct tac  *lab ;
	} b ;
	union
	{
		SYMB        *var ;
		struct tac  *lab ;
	} c ;
} TAC ;

/* When translating expressions in the syntax analyser we need to pass back as
   attribute in YACC not only the code for the expression, but where its result
   is stored. For this we use the ENODE structure. The "next" field in this
   allows it to be used for lists of expressions in function calls. typedef is
   again used for clarity */

typedef struct enode			 /* Parser expression */
{
	struct enode *next ;		 /* For argument lists */
	TAC          *tac ;		 /* The code */
	SYMB         *res ;		 /* Where the result is */
} ENODE ;

/* Global variables used throughout the compiler. "symbtab" is the hashtable.
   Each element is a list of symbol table nodes. "library" is an array holding
   the label numbers of the entry points to library routines.

   Temporary variables are given names of the form "Tnnn" where nnn is a unique
   number.  "next_tmp" holds the number of the next temporary and is
   incremented each time one is used. A similar scheme with "next_label" is
   used to assign unique labels of the form "Lnnn". */

extern SYMB *symbtab[HASHSIZE] ;	 /* Symbol table */
extern TAC  *library[LIB_MAX] ;		 /* Entries for library routines */
extern int   next_tmp ;			 /* Count of temporaries */
extern int   next_label ;		 /* Count of labels */
extern char  optiflag, filename[50] ;    /* Optimizer information */

/* Global routines that although defined in one section may be used elsewhere.
   The majority of these are in the main section of the compiler. */

extern SYMB  *mkconst( int  n ) ;	 /* In main.c */
extern SYMB  *mklabel( int  l ) ;
extern SYMB  *mktmp( void ) ;
extern TAC   *mktac( int   op,
		     SYMB *a,
		     SYMB *b,
		     SYMB *c ) ;
extern TAC   *join_tac( TAC *c1,
		        TAC *c2 ) ;
extern void   insert( SYMB *s ) ;
extern SYMB  *lookup( char *s ) ;
extern SYMB  *get_symb( void ) ;
extern void   free_symb( SYMB *s ) ;
extern ENODE *get_enode( void ) ;
extern void   free_enode( ENODE *expr ) ;
extern void  *safe_malloc( int  n ) ;
extern void   error( char *str ) ;
extern void   print_instr( TAC *i ) ;

extern void  cg( TAC *tl ) ;	 	 /* In cg.c */

extern void *malloc( int  size ) ;	 /* External routines */
//E*O*F vc.h//

exit 0

