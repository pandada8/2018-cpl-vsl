
# This is a shell archive.  Remove anything before this line, then
# unpack it by saving it in a file and typing "sh file".  (Files
# unpacked will be owned by you and have default permissions.)
#
# This archive contains:
# Makefile-vc
# header
# lib
# vc.h
# scanner.l
# parser.y
# main.c

echo x - Makefile-vc
mv Makefile-vc Makefile-vc.old
cat > "Makefile-vc" << '//E*O*F Makefile-vc//'
#
# A Makefile for the simple VSL compiler
#

# How to compile with cc

.c.o:
	cc -c $(CFLAGS) $*.c

# Flags

CFLAGS = -g -ansi -pedantic

# The files involved

HDRS = vc.h

CSRCS = main.c \
        cg.c \
        optimize.c

SRCS = $(CSRCS) \
       scanner.c \
       parser.c

OBJS = main.o \
       parser.o \
       scanner.o \
       cg.o \
       optimize.o

# Create a new compiler

vc: $(OBJS)
	cc $(CFLAGS) $(OBJS) -ll -o ../bin/vc

# C dependencies

$(OBJS): $(HDRS)

main.o: parser.h

# Dependencies of LEX and YACC files

scanner.c: scanner.l
	lex scanner.l
	mv lex.yy.c scanner.c

scanner.o: scanner.c parser.h

parser.c parser.h: parser.y
	yacc -d parser.y
	mv y.tab.c parser.c
	mv y.tab.h parser.h


# Print out the source files

print:
	enscript -2rh $(HDRS) scanner.l parser.y $(CSRCS)

# Profile option to see what's happening

profile:
	cc -p $(SRCS) -ll -o profile-vc
//E*O*F Makefile-vc//

echo x - header
mv header header.old
cat > "header" << '//E*O*F header//'
       LDA  L0,R1
       STI  R1,0(R1)
       LDA  L1,R3
//E*O*F header//

echo x - lib
mv lib lib.old
cat > "lib" << '//E*O*F lib//'
L1:
       HALT
L2:
       STI  R3,4(R1)
       LDI  8(R1),R15
       LDA  10(R0),R5
       DIV  R15,R5
       BZE  L3
       STI  R5,12(R1)
       STI  R5,24(R1)
       LDA  L2,R2
       STI  R1,16(R1)
       LDA  16(R1),R1
       BAL  R2,R3
       LDA  10(R0),R15
       LDI  8(R1),R5
       LDI  12(R1),R6
       MUL  R6,R15
       SUB  R5,R15
L3:
       LDA  48(R0),R5
       ADD  R5,R15
       TRAP
       LDI  4(R1),R2
       LDI  0(R1),R1
       BAL  R2,R3
L4:
       STI  R3,4(R1)
       LDI  8(R1),R5
       LDA  16777216(R0),R7
L5:
       LDI  0(R5),R6
       LDR  R7,R15
       DIV  R6,R15
       BZE  L6
       TRAP
       LDA  1(R5),R5
       BRA  L5
L6:
       LDI  4(R1),R2
       LDI  0(R1),R1
       BAL  R2,R3
//E*O*F lib//

echo x - vc.h
mv vc.h vc.h.old
cat > "vc.h" << '//E*O*F vc.h//'
/******************************************************************************
*******************************************************************************


          HH    HH  EEEEEEEE    AAAA    DDDDDD    EEEEEEEE  RRRRRRR 
          HH    HH  EEEEEEEE   AAAAAA   DDDDDDD   EEEEEEEE  RRRRRRRR
          HH    HH  EE        AA    AA  DD    DD  EE        RR    RR
          HHHHHHHH  EEEEEE    AAAAAAAA  DD    DD  EEEEEE    RRRRRRRR
          HH    HH  EE        AA    AA  DD    DD  EE        RRRRRRR 
          HH    HH  EE        AA    AA  DD    DD  EE        RR  RR  
          HH    HH  EEEEEEEE  AA    AA  DDDDDDD   EEEEEEEE  RR   RR 
          HH    HH  EEEEEEEE  AA    AA  DDDDDD    EEEEEEEE  RR    RR


*******************************************************************************
*******************************************************************************

			      A Compiler for VSL
			      ==================

   This is the general header file.

   Modifications:
   ==============

   22 Nov 88 JPB:  First version
   26 Apr 89 JPB:  Version for publication
   13 Jun 90 JPB:  Now refers to library directory (noted by R C Shaw, Praxis).

*******************************************************************************
******************************************************************************/

/* We start by defining the various constants used throughout the compiler. */

#define TRUE        1			 /* Booleans */
#define FALSE       0
#define EOS         0			 /* End of string */
#define HASHSIZE  997			 /* Size of symbol table */
#define R_UNDEF    -1		 	 /* Not a valid register */

/* We define the various symbol types permitted. Note the use of T_UNDEF Many
   names are entered into the symbol table by the lexical analyser before their
   type is known, and so we given them an undefined type. */

#define  T_UNDEF  0			 /* Types for symbol table */
#define  T_VAR 	  1			 /* Local Variable */
#define  T_FUNC   2			 /* Function */
#define  T_TEXT   3			 /* Static string */
#define  T_INT    4			 /* Integer constant */
#define  T_LABEL  5			 /* TAC label */

/* We define constants for each of the three address code (TAC) instructions.
   For convenience we have an undefined instruction, then we specify the 12
   main TAC opcodes. */ 

#define  TAC_UNDEF    0		 	 /* TAC instructions */
#define  TAC_ADD      1			 /* a := b + c */
#define  TAC_SUB      2			 /* a := b - c */
#define  TAC_MUL      3			 /* a := b * c */
#define  TAC_DIV      4			 /* a := b / c */
#define  TAC_NEG      5			 /* a := -b */
#define  TAC_COPY     6			 /* a := b */
#define  TAC_GOTO     7			 /* goto a */
#define  TAC_IFZ      8			 /* ifz b goto a */
#define  TAC_IFNZ     9			 /* ifnz b goto a */
#define  TAC_ARG     10			 /* arg a */
#define  TAC_CALL    11			 /* a := call b */
#define  TAC_RETURN  12			 /* return a */

/* We then add some extra "pseudo-instructions" to mark places in the code.
   TAC_LABEL s used to mark branch targets. Its first argument will be a symbol
   table entry for a label giving a unique number for this label. TAC_VAR
   is associated with variable declarations, to help in assigning stack
   locations. TAC_BEGINFUNC and TAC_ENDFUNC mark the beginning and end of
   functions respectively. */

#define  TAC_LABEL       13		 /* Marker for LABEL a */
#define  TAC_VAR         14		 /* Marker for VAR a */
#define  TAC_BEGINFUNC   15		 /* Markers for function */
#define  TAC_ENDFUNC     16

/* The library routines are supplied in an external file. Their entry points
   are held in a table, and we define the offsets in this table here as
   LIB_PRINTN and LIB_PRINTS. At present these are the only two library
   routines, used to print out numbers and strings in PRINT statements. 

   The book assumes that the code generator library and header files are in the
   same directory as the compiler. For greater flexibility we #define a library
   directory here. This will almost certainly need changing for individual
   systems. */

#define  LIB_PRINTN     0		 /* Index into library entry points */
#define  LIB_PRINTS     1
#define  LIB_MAX        2

#define  LIB_DIR  "/usr3/cs/johnsonj/comps/"  /* Library directory */

/* Many of the structures we are to use have complex unions and subfields.
   Specifying which field we are want can be verbose and for convenience we
   define some of the subfields. Thus given a pointer to a symbol table entry,
   "sp" the "text" field of the "val1" union would be referred to as
   "sp->val1.text". Instead these #define's allow us to write "sp->TEXT1". */

#define VAL1   val1.val			 /* Value val1 */
#define TEXT1  val1.text		 /* Text val1 */
#define VAL2   val2.val			 /* Value val2 */
#define LABEL2 val2.label		 /* Label val2 */
#define ADDR2  val2.val			 /* Address val2 */
#define ETYPE  res->type		 /* Type of expr result */
#define EVAL1  res->val1.val             /* Value field in expr */
#define VA     a.var			 /* Var result in TAC */
#define LA     a.lab			 /* Label result in TAC */
#define VB     b.var			 /* Var first arg in TAC */
#define LB     b.lab			 /* Label first arg in TAC */
#define VC     c.var			 /* Var second arg in TAC */
#define LC     c.lab			 /* Label second arg in TAC */

/* This is the central structure of the compiler, the symbol table entry, SYMB.
   The symbol table takes the form of an open hash table. The entries are
   linked via the "next" field and have a "type" field. The value of this field
   determines the use made of the two value fields, which may hold text
   pointers or intgers. The whole is set up using a typedef for clarity in the
   code.

   For convenience the same structure is used for items like constants and
   labels even if they do not need to be entered into the symbol table. This
   makes for a simpler TAC data structure. */

typedef struct symb			 /* Symbol table entry */
{
	struct symb *next ;		 /* Next in chain */
	int          type ;		 /* What is this symbol */
	union				 /* Primary value */
	{
		int         val ;	 /* For integers */
		char       *text ;	 /* For var names */
	} val1 ;
	union				 /* Secondary value */
	{
		int         val ;	 /* For offsets etc */
		struct tac *label ;	 /* For branches */
	} val2 ;
} SYMB ;

/* TAC is stored as a doubly-linked list of quadruples. In general we will pass
   round pointers to the last generated quadruple in the syntax analyser and
   first generated quadruple in the code generator. The opcode is an integer
   and the argument and the result fields are either pointers to symbol table
   entries or pointers to other TAC quadruples (for branch instructions). The
   names of the fields are based on TAC instructions of the form

      a := b op c

   Again this is implemented as a typedef for convenience */

typedef struct tac			 /* TAC instruction node */
{
	struct tac  *next ;		 /* Next instruction */
	struct tac  *prev ;		 /* Previous instruction */
	int          op ;		 /* TAC instruction */
	union				 /* Result */
	{
		SYMB        *var ;	 /* Name */
		struct tac  *lab ;	 /* Address */
	} a ;
	union		 		 /* Operands */
	{
		SYMB        *var ;
		struct tac  *lab ;
	} b ;
	union
	{
		SYMB        *var ;
		struct tac  *lab ;
	} c ;
} TAC ;

/* When translating expressions in the syntax analyser we need to pass back as
   attribute in YACC not only the code for the expression, but where its result
   is stored. For this we use the ENODE structure. The "next" field in this
   allows it to be used for lists of expressions in function calls. typedef is
   again used for clarity */

typedef struct enode			 /* Parser expression */
{
	struct enode *next ;		 /* For argument lists */
	TAC          *tac ;		 /* The code */
	SYMB         *res ;		 /* Where the result is */
} ENODE ;

/* Global variables used throughout the compiler. "symbtab" is the hashtable.
   Each element is a list of symbol table nodes. "library" is an array holding
   the label numbers of the entry points to library routines.

   Temporary variables are given names of the form "Tnnn" where nnn is a unique
   number.  "next_tmp" holds the number of the next temporary and is
   incremented each time one is used. A similar scheme with "next_label" is
   used to assign unique labels of the form "Lnnn". */

extern SYMB *symbtab[HASHSIZE] ;	 /* Symbol table */
extern TAC  *library[LIB_MAX] ;		 /* Entries for library routines */
extern int   next_tmp ;			 /* Count of temporaries */
extern int   next_label ;		 /* Count of labels */
extern char  optiflag, filename[50] ;    /* Optimizer information */

/* Global routines that although defined in one section may be used elsewhere.
   The majority of these are in the main section of the compiler. */

extern SYMB  *mkconst( int  n ) ;	 /* In main.c */
extern SYMB  *mklabel( int  l ) ;
extern SYMB  *mktmp( void ) ;
extern TAC   *mktac( int   op,
		     SYMB *a,
		     SYMB *b,
		     SYMB *c ) ;
extern TAC   *join_tac( TAC *c1,
		        TAC *c2 ) ;
extern void   insert( SYMB *s ) ;
extern SYMB  *lookup( char *s ) ;
extern SYMB  *get_symb( void ) ;
extern void   free_symb( SYMB *s ) ;
extern ENODE *get_enode( void ) ;
extern void   free_enode( ENODE *expr ) ;
extern void  *safe_malloc( int  n ) ;
extern void   error( char *str ) ;
extern void   print_instr( TAC *i ) ;

extern void  cg( TAC *tl ) ;	 	 /* In cg.c */

extern void *malloc( int  size ) ;	 /* External routines */
//E*O*F vc.h//

echo x - scanner.l
mv scanner.l scanner.l.old
cat > "scanner.l" << '//E*O*F scanner.l//'
%{
/******************************************************************************
*******************************************************************************


      SSSSSS     CCCCC     AAAA    NN    NN  NN    NN  EEEEEEEE  RRRRRRR 
     SSSSSSSS   CCCCCCC   AAAAAA   NNN   NN  NNN   NN  EEEEEEEE  RRRRRRRR
     SS        CC        AA    AA  NNNN  NN  NNNN  NN  EE        RR    RR
     SSSSSSS   CC        AAAAAAAA  NN NN NN  NN NN NN  EEEEEE    RRRRRRRR
           SS  CC        AA    AA  NN  NNNN  NN  NNNN  EE        RRRRRRR 
           SS  CC        AA    AA  NN  NNNN  NN  NNNN  EE        RR  RR  
     SSSSSSSS   CCCCCCC  AA    AA  NN   NNN  NN   NNN  EEEEEEEE  RR   RR 
      SSSSSS     CCCCC   AA    AA  NN    NN  NN    NN  EEEEEEEE  RR    RR


*******************************************************************************
*******************************************************************************

			      A Compiler for VSL
			      ==================
   A scanner for VSL

   Modifications:
   ==============

   16 Nov 88 JPB:  First version
   26 Apr 89 JPB:  Simple version
   25 Jul 89 JPB:  Final version for publication

*******************************************************************************
******************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include "vc.h"
#include "parser.h"

/* Routines defined here. These are in the code section below and build symbol
   table entries for variable names, integer constants and text strings
   respectively. */ 

void  mkname( void ) ;
void  mkval( void ) ;
void  mktext( void ) ;

/* We define some useful patters using regular expressions as described in
   chapter 5. Note how earlier definitions are used later (e.g. the definition
   of "delimiter" in the definition of "whitespace". These patterns are very
   straightforward, since all VSL reserved words use upper case letters and
   variable names use only lower case. */

%}

comment		"//".*
delimiter	[ \t\n]
whitespace	{delimiter}+
uc_letter	[A-Z]
lc_letter	[a-z]
letter		{lc_letter}|{uc_letter}
ascii_char	[^\"\n]
escaped_char	\\n|\\\"
digit		[0-9]
variable	{lc_letter}({lc_letter}|{digit})*
integer		{digit}+
text		\"({ascii_char}|{escaped_char})*\"

%{
/* Now follows the rule section. We wish to return the appropriate token in
   each case. We start with rules to ignore comments (everything from // to the
   end of line) and white space. Then come the three complex lexemes,
   "variable", "integer" and "text". In each case we call "mkxxx()" to build an
   appropriate symbol table entry from "yytext" and put the result in "yylval",
   as the attribute to go back with the token.

   We then include patterns to recognise the assign symbol, ":=", and the
   reserved words.

   Anything that has not been recognised will then be picked up by the last
   match, which is for single character tokens. This will only be used if
   nothing longer can be matched. Single character variables and integers will
   not be picked up by this, even though they are the same length, because
   their rule is specified earlier. An alternative approach would be to specify
   the individual single character tokens that are permissible and return an
   "ERROR" token for any other single character. The arrangement as it stands
   leaves detection of such errors to the parser. */
%}

%%

{comment}	{ 			 /* Ignore comments */ }
{whitespace}	{ 			 /* Ignore whitespace */ }
{variable}	{ mkname() ;             /* Save the variable name */
		  return VARIABLE ;  	 /* A variable name */ }
{integer}	{ mkval() ;		 /* Save the integer value */
		  return INTEGER ;   	 /* A number */ }
{text}		{ mktext() ;		 /* Save the text string */
		  return TEXT ;      	 /* A string */ }
":="		{ return ASSIGN_SYMBOL ; /* ':=' */ }
FUNC		{ return FUNC ;      	 /* 'FUNC' */ }
PRINT		{ return PRINT ;	 /* 'PRINT' */ }
RETURN		{ return RETURN ;	 /* 'RETURN' */ }
CONTINUE	{ return CONTINUE ;	 /* 'CONTINUE' */ }
IF		{ return IF ;		 /* 'IF' */ }
THEN		{ return THEN ;		 /* 'THEN' */ }
ELSE		{ return ELSE ;		 /* 'ELSE' */ }
FI		{ return FI ;		 /* 'FI' */ }
WHILE		{ return WHILE ;	 /* 'WHILE' */ }
DO		{ return DO ;		 /* 'DO' */ }
DONE		{ return DONE ;		 /* 'DONE' */ }
VAR		{ return VAR ;		 /* 'VAR' */ }
.		{ return yytext[0] ; 	 /* Single character operator */ }

%%

/* Support code */


void  mkname( void )

/* Lookup a name in the symbol table. If not there set up a new one, returning
   the result in "yylval". Note that "yylval" is a union, defined in parser.h
   and so we must specify which member of the union (in this case "symb") we
   wish to used. We insert the name in the symbol table, but at this stage with
   type T_UNDEF, since we do not know what its type is. */

{
	struct symb *t ;		 /* Pointer to looked up symbol */
	char        *s ;		 /* Permanent text of string */

	/* If the string exists return with it in yylval */

	if((t = lookup( yytext )) != NULL )
	{
		yylval.symb = t ;
		return ;
	}

	/* Unseen before, so make a permanent copy, set up a new symbol table
	   node, insert it into the symbol table and assign it to yylval. */

	s = (char *)safe_malloc( yyleng + 1 ) ;	 /* Space for permanent copy */

	strncpy( s, yytext, yyleng ) ;
	s[yyleng] = EOS ;

	t        = get_symb() ;
	t->type  = T_UNDEF ;		 /* Don't know which node type yet */
	t->TEXT1 = s ;			 /* Text argument */

	insert( t ) ;
	yylval.symb = t ;		 /* Symbol type in union */

}	/* void  mkname( void ) */


void  mkval( void )

/* Set up a node for an integer read by the scanner. We use the library routine
   "atoi()" to convert the text of "yytext" to an integer. */

{
	yylval.symb = mkconst( atoi( yytext )) ;

}	/* void  mkval( void ) */


void  mktext( void )

/* Text is treated very similarly to a variable name. "mktext()" uses
   "mkname()" to do most of the work, and then just changes the relevant
   fields. Strings will be put out as constant data at the end of the program
   and we give it a label to mark its beginning. Note that there is no risk of
   a piece of text being mistaken for a variable name during symbol lookup,
   since the text field of a text node includes the surrounding quotes. */

{
	mkname() ;
	yylval.symb->type = T_TEXT ;
	yylval.symb->VAL2 = next_label++ ;

}	/* mktext( void ) */
//E*O*F scanner.l//

echo x - parser.y
mv parser.y parser.y.old
cat > "parser.y" << '//E*O*F parser.y//'
/******************************************************************************
*******************************************************************************


          PPPPPPP     AAAA    RRRRRRR    SSSSSS   EEEEEEEE  RRRRRRR 
          PPPPPPPP   AAAAAA   RRRRRRRR  SSSSSSSS  EEEEEEEE  RRRRRRRR
          PP    PP  AA    AA  RR    RR  SS        EE        RR    RR
          PPPPPPP   AAAAAAAA  RRRRRRRR  SSSSSSS   EEEEEE    RRRRRRRR
          PP        AA    AA  RRRRRRR         SS  EE        RRRRRRR 
          PP        AA    AA  RR  RR          SS  EE        RR  RR  
          PP        AA    AA  RR   RR   SSSSSSSS  EEEEEEEE  RR   RR 
          PP        AA    AA  RR    RR   SSSSSS   EEEEEEEE  RR    RR


*******************************************************************************
*******************************************************************************

			      A Compiler for VSL
			      ==================

   This is the YACC parser. It creates a tree representation of the program for
   subsequent conversion to TAC.

   Modifications:
   ==============

   16 Nov 88 JPB:  First version
   26 Apr 89 JPB:  Version for publication
   27 Jul 89 JPB:  Final version for publication

*******************************************************************************
******************************************************************************/

%{

/* We include the standard headers, but not "parser.h", since that will be
   produced by YACC when the YACC program is translated. */

#include <stdio.h>
#include <ctype.h>
#include "vc.h"

/* These are the prototypes of routines defined and used in the parser */

TAC   *do_program( TAC *c ) ;
TAC   *do_func( SYMB *func,
	      TAC  *args,
	      TAC  *code ) ;
TAC   *declare_var( SYMB *var ) ;
TAC   *do_assign( SYMB  *var,
		ENODE *expr ) ;
ENODE *do_bin(  int    binop,
		ENODE *expr1,
		ENODE *expr2 ) ;
ENODE *do_un(  int    unop,
	       ENODE *expr ) ;
ENODE *do_fnap( SYMB  *func,
		ENODE *arglist ) ;
TAC   *do_lib( int   rtn,
	     SYMB *arg ) ;
TAC   *do_if( ENODE *expr,
	    TAC   *stmt ) ;
TAC   *do_test( ENODE *expr,
	      TAC   *stmt1,
	      TAC   *stmt2 ) ;
TAC   *do_while( ENODE *expr,
	       TAC   *stmt ) ;
ENODE *mkenode( ENODE *next,
		SYMB  *res,
		TAC   *code ) ;
void  yyerror( char *str ) ;

%}

/* %union defines the type of attribute to be synthesised by the semantic
   actions. The variables, constants and text produced by the lexical analyser
   will be symbol table nodes. Most YACC rules will produce lists of TAC,
   however those involving expressions will need to use "enode's" to specify
   where the result of the TAC is put. */

%union
{
	SYMB   *symb ;		 /* For vars, consts and text */
	TAC    *tac ;		 /* For most things */
	ENODE  *enode ;		 /* For expressions */
}

/* Tokens. Most of these don't need types, since they have no associated
   attribute. However variables, integers and text have to have a more complex
   structure, since they return symbol table nodes as attributes. */

%token         FUNC			 /* 'FUNC' */
%token <symb>  VARIABLE			 /* variable name */
%token         ASSIGN_SYMBOL		 /* ':=' */
%token <symb>  INTEGER			 /* integer number */
%token         PRINT			 /* 'PRINT' */
%token <symb>  TEXT			 /* quoted text */
%token         RETURN			 /* 'RETURN' */
%token         CONTINUE			 /* 'CONTINUE */
%token         IF			 /* 'IF' */
%token         THEN			 /* 'THEN' */
%token         ELSE			 /* 'ELSE' */
%token         FI			 /* 'FI' */
%token         WHILE			 /* 'WHILE' */
%token         DO			 /* 'DO' */
%token         DONE			 /* 'DONE' */
%token         VAR			 /* 'VAR' */
%token         UMINUS			 /* used for precedence */

/* Now type declarations for the non-terminals. Most non-terminals just return
   a list of TAC as result, however expressions also return a pointer to the
   symbol holding the result of the calculation. */

%type <tac>     program
%type <tac>     function_list
%type <tac>     function
%type <tac>     parameter_list
%type <tac>     variable_list
%type <enode>   argument_list
%type <enode>   expression_list
%type <tac>     statement
%type <tac>     assignment_statement
%type <enode>   expression
%type <tac>     print_statement
%type <tac>     print_list
%type <tac>     print_item
%type <tac>     return_statement
%type <tac>     null_statement
%type <tac>     if_statement
%type <tac>     while_statement
%type <tac>     block
%type <tac>     declaration_list
%type <tac>     declaration
%type <tac>     statement_list
%type <tac>     error

/* We define the precedence of the arithmetic operators, including a
   pseudo-token, "UMINUS" to be used for unary minus when it occurs in
   expressions. */

%left  '+' '-'
%left  '*' '/'
%right UMINUS

%%

/* These are the grammar rules. "program" is the sentence symbol of the
   grammar. It uses the default action $$ = $1 ; to pass back the TAC
   constructed. */

program			:	function_list
			;

/* "function_list" is typical of may rules with two parts. Where we have a
   "function_list" followed by a "function" we call "join_tac()" to combine the
   code for each into one. Note that this use of "join_tac()", involving a walk
   down one of the code lists is very inefficient if the code gets at all
   large. If we intend using VSL for major programs (admittedly unlikely), then
   we should wish to avoid this each time we joined code. We should probably
   chose to use a non-linked TAC representation and place markers as discussed
   in chapter 6. */

function_list		:	function
			|	function_list function
				{
					$$ = join_tac( $1, $2 ) ;
				}
			;

/* Note that when we start a new "function" we are able to set the temporary
   variable count back to zero, since temporary variable names need only be
   unique within the function where they are declared. Like most rules we call
   a subsidiary routine, "do_func()", to build the code.

   This is one of the places where we attempt rudimentary error recovery. We do
   not specify a synchronising set, but let the parser recover for itself. */

function		:	FUNC VARIABLE '(' parameter_list ')'
			        statement
				{
					next_tmp = 0 ;
					$$ = do_func( $2, $4, $6 ) ;
				}
			|	error
				{
					error( "Bad function syntax" ) ;
					$$ = NULL ;
				}
			;

parameter_list		:	variable_list
			|
				{
					$$ = NULL ;
				}
			;

variable_list		:	VARIABLE
				{
					$$ = declare_var( $1 ) ;
				}		
			|	variable_list ',' VARIABLE
				{
					TAC *t = declare_var( $3 ) ;

					t->prev = $1 ;
					$$ = t ;
				}		
			;

statement		:	assignment_statement
			|	return_statement
			|	print_statement
			|	null_statement
			|	if_statement
			|	while_statement
			|	block
			|   	error
				{
					error( "Bad statement syntax" ) ;
					$$ = NULL ;
				}
			;

assignment_statement	:	VARIABLE ASSIGN_SYMBOL expression
				{

					$$ = do_assign( $1, $3 ) ;
				}
			;

/* Rules for expressions. Note the use of "%prec UMINUS" to define the higher
   precedence of negation. */

expression		:	expression '+' expression
				{
					$$ = do_bin( TAC_ADD, $1, $3 ) ;
				}
			|	expression '-' expression
				{
					$$ = do_bin( TAC_SUB, $1, $3 ) ;
				}
			|	expression '*' expression
				{
					$$ = do_bin( TAC_MUL, $1, $3 ) ;
				}
			|	expression '/' expression
				{
					$$ = do_bin( TAC_DIV, $1, $3 ) ;
				}
			|	'-' expression  %prec UMINUS
				{
					$$ = do_un( TAC_NEG, $2 ) ;
				}
			|	'(' expression ')'
				{
					$$ = $2 ;
				}		
			|	INTEGER
				{
					$$ = mkenode( NULL, $1, NULL ) ;
				}
			|	VARIABLE
				{
					$$ = mkenode( NULL, $1, NULL ) ;
				}
			|	VARIABLE '(' argument_list ')'
				{
					$$ = do_fnap( $1, $3 ) ;
				}		
			|   	error
				{
					error( "Bad expression syntax" ) ;
					$$ = mkenode( NULL, NULL, NULL ) ;
				}
			;

argument_list		:
				{
					$$ = NULL ;
				}
			|	expression_list
			;

expression_list		:	expression
			|	expression_list ',' expression
				{

					/* Construct a list of expr nodes */

					$1->next = $3 ;
					$$       = $1 ;
				}
			;

print_statement		:	PRINT print_list
				{
					$$ = $2 ;
				}		
			;

print_list		:	print_item
			|	print_list ',' print_item
				{
					$$ = join_tac( $1, $3 ) ;
				}		
			;

/* PRINT items are handled by calls to library routines. These take as their
   argument the libary routine to call and the symbol to pass as argument. */

print_item		:	expression
				{

					/* Call printn library routine */

					$$ = join_tac( $1->tac,
						       do_lib( LIB_PRINTN,
						       $1->res )) ;
				}
			|	TEXT
				{

					/* Call prints, passing the address of
					   the string */

					$$ = do_lib( LIB_PRINTS, $1 ) ;
				}
			;

return_statement	:	RETURN expression
				{
					TAC *t = mktac( TAC_RETURN, $2->res,
							NULL, NULL ) ;
					t->prev = $2->tac ;
					free_enode( $2 ) ;
					$$      = t ;
				}		
			;

null_statement		:	CONTINUE
				{
					$$ = NULL ;
				}		
			;

/* Note the use of two different routines to handle the different types of IF
   statement. We could have shared this code for conciseness. */

if_statement		:	IF expression THEN statement FI
				{
					$$ = do_if( $2, $4 ) ;
				}
			|	IF expression THEN statement
			        ELSE statement FI
				{
					$$ = do_test( $2, $4, $6 ) ;
				}
			;

while_statement		:	WHILE expression DO statement DONE
				{
					$$ = do_while( $2, $4 ) ;
				}		
			;

block			:	'{' declaration_list statement_list '}'
				{
					$$ = join_tac( $2, $3 ) ;
				}		
			;

declaration_list	:
				{
					$$ = NULL ;
				}
			|	declaration_list declaration
				{
					$$ = join_tac( $1, $2 ) ;
				}
			;

declaration		:	VAR variable_list
				{
					$$ = $2 ;
				}
			;

statement_list		:	statement

			|	statement_list statement
				{
					$$ = join_tac( $1, $2 ) ;
				}		
			;

%%

/* These are the routines to support the various YACC rules. It is invariably
   clearer to put anything but the simplest semantic action in a routine,
   because the layout of YACC bunches code to the right so much. */


TAC *do_func( SYMB *func,	 		 /* Function */
	      TAC  *args,	 		 /* Its args */
	      TAC  *code )	 		 /* Its code */

/* For a function we must add TAC_BEGINFUNC and TAC_ENDFUNC quadruples
   around it, and a new label at the start. We then enter the name of the
   function in the symbol table. It should not have been declared as a variable
   or function elsewhere, and so should still have type T_UNDEF.

   The function may already be the subject of function calls. The address of
   the quadruples for these calls are held in the LABEL2 field of its symbol
   table entry, ready for backpatching. We run down this list backpatching in
   the address of the starting label, and then replace the field with the
   address of the starting label, also updating the type to T_FUNC.

   Note that there is a fault in the compiler at this point. If we never
   declare a function that is used, then its address will never be backpatched.
   This is a semantic check that needs to be added at the end of parsing. */

{
	TAC *tlist ;			 /* The backpatch list */

	TAC *tlab ;			 /* Label at start of function */
	TAC *tbegin ;			 /* BEGINFUNC marker */
	TAC *tend ;			 /* ENDFUNC marker */

	/* Add this function to the symbol table. If its already there its been
	   used before, so backpatch the address into the call opcodes. If
	   declared already we have a semantic error and give up. Otherwise
	   patch in the addresses and declare as a function */

	if( func->type != T_UNDEF )
	{
		error( "function already declared" ) ;
		return NULL ;
	}

	tlab   = mktac( TAC_LABEL,     mklabel( next_label++ ), NULL, NULL ) ;
	tbegin = mktac( TAC_BEGINFUNC, NULL, NULL, NULL ) ;
	tend   = mktac( TAC_ENDFUNC,   NULL, NULL, NULL ) ;

	tbegin->prev = tlab ;
	code         = join_tac( args, code ) ;
	tend->prev   = join_tac( tbegin, code ) ;

	tlist = func->LABEL2 ;			 /* List of addresses if any */

	while( tlist != NULL )
	{
		TAC *tnext = tlist->LB ;  	 /* Next on list */

		tlist->LB  = tlab ;
		tlist      = tnext ;
	}

	func->type   = T_FUNC ;		 /* And declare as func */
	func->LABEL2 = tlab ;

	return tend ;

}	/* TAC *do_func( SYMB *func,
		     	 TAC  *args,
			 TAC  *code ) */


TAC *declare_var( SYMB *var )

/* All variable names may be used only once throughout a program. We check here
   that they have not yet been declared and if so declare them, setting their
   stack offset to -1 (an invalid offset) and marking their address descriptor
   empty. Note that this is a fault in the compiler. We really do need to mark
   the beginning and end of blocks in which variables are declared, so that
   scope can be checked. */

{
	if( var->type != T_UNDEF )
	{
		error( "variable already declared" ) ;
		return NULL ;
	}

	var->type  = T_VAR ;
	var->ADDR2 = -1 ;		 /* Unset address */

	/* TAC for a declaration */

	return  mktac( TAC_VAR, var, NULL, NULL ) ;

}	/* TAC *declare_var( SYMB *var ) */


TAC *do_assign( SYMB  *var,	 /* Variable to be assigned */
		ENODE *expr )	 /* Expression to assign */

/* An assignment statement shows the use of expression nodes. We construct a
   copy node to take the result of the expression and copy it into the
   variable, having performed suitable semantic checks. Note that if we
   discover that the variable has not been declared, we declare it, to prevent
   further non-declaration errors each time it is referenced. */

{
	TAC  *code ;

	/* Warn if variable not declared, then build code */

	if( var->type != T_VAR )
		error( "assignment to non-variable" ) ;

	code       = mktac( TAC_COPY, var, expr->res, NULL ) ;
	code->prev = expr->tac ;
	free_enode( expr ) ;		 /* Expression now finished with */

	return code ;

}	/* TAC *do_assign( SYMB  *var,
			   ENODE *expr ) */


ENODE *do_bin(  int    binop,		 /* TAC binary operator */
		ENODE *expr1,		 /* Expressions to operate on */
		ENODE *expr2 )

/* We then have the first of the arithmetic routines to handles binary
   operators.  We carry out one of the few optimisations in the compiler here,
   constant folding, reusing the expression node for efficiency. If we can't do
   folding we generate the result into a temporary variable, which we first
   declare, returning an expression node for the TAC with the temporary in the
   result field. */

{
	TAC  *temp ;			 /* TAC code for temp symbol */
	TAC  *res ;			 /* TAC code for result */

        if(( binop == TAC_DIV ) && ( expr2->EVAL1 == 0))
                error( "division by zero" ); /* Division by zero! */

	/* Do constant folding if possible. Calculate the constant into expr1
	   and free up expr2. */

	if(( expr1->ETYPE == T_INT ) && ( expr2->ETYPE == T_INT ))
	{
		switch( binop )		 /* Chose the operator */
		{
		case TAC_ADD:

			expr1->EVAL1 = expr1->EVAL1 + expr2->EVAL1 ;
			break ;

		case TAC_SUB:

			expr1->EVAL1 = expr1->EVAL1 - expr2->EVAL1 ;
			break ;

		case TAC_MUL:

			expr1->EVAL1 = expr1->EVAL1 * expr2->EVAL1 ;
			break ;

		case TAC_DIV:

			expr1->EVAL1 = expr1->EVAL1 / expr2->EVAL1 ;
			break ;
		}

		free_symb( expr2->res ) ;  /* Release space in expr2 */
		free_enode( expr2 ) ;

		return expr1 ;		   /* The new expression */
	}

	/* Not constant, so create a TAC node for a binary operator, putting
	   the result in a temporary. Bolt the code together, reusing expr1 and
	   freeing expr2. */

	temp       = mktac( TAC_VAR, mktmp(), NULL, NULL ) ;
	temp->prev = join_tac( expr1->tac, expr2->tac ) ;
	res        = mktac( binop, temp->VA, expr1->res, expr2->res ) ;
	res->prev  = temp ;

	expr1->res = temp->VA ;
	expr1->tac = res ;
	free_enode( expr2 ) ;

	return expr1 ;	

}	/* ENODE *do_bin(  int    binop,
	 		   ENODE *expr1,
			   ENODE *expr2 ) */


ENODE *do_un(  int    unop,		 /* TAC unary operator */
	       ENODE *expr )		 /* Expression to operate on */

/* This is an analagous routine to deal with unary operators. In the interests
   of generality it has been written to permit easy addition of new unary
   operators, although there is only one at present. */


{
	TAC  *temp ;			 /* TAC code for temp symbol */
	TAC  *res ;			 /* TAC code for result */

	/* Do constant folding if possible. Calculate the constant into expr */

	if( expr->ETYPE == T_INT )
	{
		switch( unop )		 /* Chose the operator */
		{
		case TAC_NEG:

			expr->EVAL1 = - expr->EVAL1 ;
			break ;
		}

		return expr ;		   /* The new expression */
	}

	/* Not constant, so create a TAC node for a unary operator, putting
	   the result in a temporary. Bolt the code together, reusing expr. */

	temp       = mktac( TAC_VAR, mktmp(), NULL, NULL ) ;
	temp->prev = expr->tac ;
	res        = mktac( unop, temp->VA, NULL, expr->res ) ;
	res->prev  = temp ;

	expr->res = temp->VA ;
	expr->tac = res ;

	return expr ;	

}	/* ENODE *do_un(  int    unop,
	 		  ENODE *expr ) */


ENODE *do_fnap( SYMB  *func,		 /* Function to call */
		ENODE *arglist )	 /* Its argument list */

/* Construct a function call to the given function. If the function is not yet
   defined, then we must add this call to the backpatching list. Return the
   result of the function in a temporary. Note the qualication about
   backpatching above in the definition of "do_func()"

   When constructing a function call we put the result in a temporary. We join
   all the TAC for the expressions first, then join the code for the TAC_ARG
   instructions, since arg instructions must appear consecutively. */

{
	ENODE  *alt ;			 /* For counting args */
	SYMB   *res ;			 /* Where function result will go */
	TAC    *code ;			 /* Resulting code */
	TAC    *temp ;			 /* Temporary for building code */

	/* Check that this is a valid function. In this case it must either be
	   T_UNDEF or T_FUNC. If it is declare the result, run down the
	   argument list, joining up the code for each argument, then generate
	   a sequence of arg instructions and finally a call instruction */

	if(( func->type != T_UNDEF ) && ( func->type != T_FUNC ))
	{
		error( "function declared other than function" );
		return NULL ;
	}

	res   = mktmp() ;		             /* For the result */
	code  = mktac( TAC_VAR, res, NULL, NULL ) ;

	for( alt = arglist ; alt != NULL ; alt = alt->next )  /* Join args */
		code = join_tac( code, alt->tac ) ;

	while( arglist != NULL )	 /* Generate ARG instructions */
	{
		temp       = mktac( TAC_ARG, arglist->res, NULL, NULL ) ;
		temp->prev = code ;
		code       = temp ;

		alt = arglist->next ;
		free_enode( arglist ) ;	 /* Free the space */
		arglist = alt ;
	} ;

	temp       = mktac( TAC_CALL, res, (SYMB *)func->LABEL2, NULL ) ;
	temp->prev = code ;
	code       = temp ;

	/* If the function is undefined update its backpatching list with the
	   address of this instruction and then return an expression node for
	   the result */

	if( func->type == T_UNDEF )
		func->LABEL2 = code ;

	return mkenode( NULL, res, code ) ;

}	/* ENODE *do_fnap( SYMB  *func,
		           ENODE *arglist ) */


TAC *do_lib( int   rtn,			 /* Routine to call */
	     SYMB *arg )		 /* Argument to pass */

/* PRINT items are handled by calls to library routines. These take as their
   argument the libary routine to call and the symbol to pass as argument.
   This routine constructs a call to a libary routine with a single argument.
*/

{
	TAC *a = mktac( TAC_ARG, arg, NULL, NULL ) ;
	TAC *c = mktac( TAC_CALL, NULL, (SYMB *)library[rtn], NULL ) ;

	c->prev = a ;

	return c ;

}	/* TAC *do_lib( int   rtn,
	   		SYMB *arg ) */


TAC *do_if( ENODE *expr,		 /* Condition */
	    TAC   *stmt )		 /* Statement to execute */

/* For convenience we have two routines to handle IF statements, "do_if()"
   where there is no ELSE part and "do_test()" where there is. We always
   allocate TAC_LABEL instructions, so that the destinations of all branches
   will appear as labels in the resulting TAC code. */

{
	TAC *label = mktac( TAC_LABEL, mklabel( next_label++ ), NULL, NULL ) ;
	TAC *code  = mktac( TAC_IFZ, (SYMB *)label, expr->res, NULL ) ;

	code->prev  = expr->tac ;
	code        = join_tac( code, stmt ) ;
	label->prev = code ;

	free_enode( expr ) ;		 /* Expression finished with */

	return label ;

}	/* TAC *do_if( ENODE *expr,
	    	       TAC   *stmt ) */


TAC *do_test( ENODE *expr,		 /* Condition */
	      TAC   *stmt1,		 /* THEN part */
	      TAC   *stmt2 )		 /* ELSE part */

/* Construct code for an if statement with else part */

{
	TAC *label1 = mktac( TAC_LABEL, mklabel( next_label++ ), NULL, NULL ) ;
	TAC *label2 = mktac( TAC_LABEL, mklabel( next_label++ ), NULL, NULL ) ;
	TAC *code1  = mktac( TAC_IFZ, (SYMB *)label1, expr->res, NULL ) ;
	TAC *code2  = mktac( TAC_GOTO, (SYMB *)label2, NULL, NULL ) ;

	code1->prev  = expr->tac ;		        /* Join the code */
	code1        = join_tac( code1, stmt1 ) ;
	code2->prev  = code1 ;
	label1->prev = code2 ;
	label1       = join_tac( label1, stmt2 ) ;
	label2->prev = label1 ;

	free_enode( expr ) ;		 /* Free the expression */

	return label2 ;

}	/* TAC *do_test( ENODE *expr,
	      		 TAC   *stmt1,
	      		 TAC   *stmt2 ) */


TAC *do_while( ENODE *expr,		 /* Condition */
	       TAC   *stmt )		 /* Body of loop */

/* Do a WHILE loop. This is the same as an IF statement with a jump back at the
   end. We bolt a goto on the end of the statement, call do_if to construct the
   code and join the start label right at the beginning */

{
	TAC *label = mktac( TAC_LABEL, mklabel( next_label++ ), NULL, NULL ) ;
	TAC *code  = mktac( TAC_GOTO, (SYMB *)label, NULL, NULL ) ;

	code->prev = stmt ;		 /* Bolt on the goto */

	return join_tac( label, do_if( expr, code )) ;

}	/* TAC *do_while( ENODE *expr,
	       		  TAC   *stmt ) */


ENODE *mkenode( ENODE *next,
		SYMB  *res,
		TAC   *code )

/* The routine to make an expression node. We put this here rather than with
   the other utilities in "main.c", since it is only used in the parser. */

{
	ENODE *expr = get_enode() ;

	expr->next = next ;
	expr->res  = res ;
	expr->tac  = code ;

	return expr ;

}	/* ENODE *mkenode( ENODE *next,
			   SYMB  *res,
			   TAC   *code ) */


void  yyerror( char *str )

/* The Yacc default error handler. This just calls our error handler */

{
	error( str ) ;

}	/* void  yyerror( char *str ) */
//E*O*F parser.y//

echo x - main.c
mv main.c main.c.old
cat > "main.c" << '//E*O*F main.c//'
/******************************************************************************
*******************************************************************************


                    MM    MM    AAAA    IIIIIIII  NN    NN
                    MMM  MMM   AAAAAA   IIIIIIII  NNN   NN
                    MMMMMMMM  AA    AA     II     NNNN  NN
                    MM MM MM  AAAAAAAA     II     NN NN NN
                    MM    MM  AA    AA     II     NN  NNNN
                    MM    MM  AA    AA     II     NN  NNNN
                    MM    MM  AA    AA  IIIIIIII  NN   NNN
                    MM    MM  AA    AA  IIIIIIII  NN    NN


*******************************************************************************
*******************************************************************************

			      A Compiler for VSL
			      ==================

   These are the main, initialisation, tidy up and utility routines.

   Modifications:
   ==============

   22 Nov 88 JPB:  First version
   26 Apr 89 JPB:  Version for publication
   13 Jun 90 JPB:  mklabel fixed to return t

*******************************************************************************
******************************************************************************/

/* As well as including the general header we include the header "parser.h"
   generated by YACC, which contains definitions of all the terminals. Note
   that this is the file "y.tab.h" obtained by running yacc with the -d option.
   We rename it "parser.h" when building the compiler for clarity. */

#include <stdio.h>
#include <ctype.h>
#include "vc.h"
#include "parser.h"

/* Constants used here. CONST_MAX gives the number of small integers
   pre-intialised in the symbol table (described later). LAB_MIN is the first
   label number to be used. Label L0 is reserved for the end of code and data
   and L1 for the termination routine. Labels up to LAB_MIN - 1 may be used by
   the library routines. */

#define CONST_MAX  5
#define LAB_MIN   10

/* We also declare as external the text array and associated variables,
   "yytext" , "yyleng" and "yylval" defined in the parser and scanner which we
   will need to refer to in this section. */

extern char    yytext[] ;
extern int     yyleng ;
extern YYSTYPE yyval ;

/* We define a number of static variables used throughout the compiler. These
   have been declared external in the header file, and are defined here. */

SYMB  *symbtab[HASHSIZE] ;		 /* Symbol table */
TAC   *library[LIB_MAX] ;		 /* Entries for library routines */
int    next_tmp ;			 /* Count of temporaries */
int    next_label ;			 /* Count of labels */
char   optiflag, filename[50] ;          /* Optimizer information */

/* These are static variables used throughout this section. "const_tab" is the
   table of predeclared integers. "errors_found" is a flag set if the error
   routine is ever called. We do not bother to generate code if errors are
   found during parsing.

   Symbol table and expression nodes are regularly allocated, freed and
   reallocated. Rather than use the system routines "malloc()" and "free()"
   directly for this, we maintain our own freelists, held in "symb_list" and
   "enode_list". */

SYMB  *const_tab[CONST_MAX] ;		 /* Small constants */
int    errors_found ;			 /* True if we have any errors */
SYMB  *symb_list ;			 /* Freelists */
ENODE *enode_list ;

/* Prototypes of routines defined in this section. */

void   main( int argc, char **argv ) ;
void   init_vc( int argc, char **argv ) ;
SYMB  *mkconst( int  n ) ;
SYMB  *mklabel( int  l ) ;
SYMB  *mktmp( void ) ;
SYMB  *get_symb( void ) ;
void   free_symb( SYMB *s ) ;
ENODE *get_enode( void ) ;
void   free_enode( ENODE *e ) ;
void  *safe_malloc( int  n ) ;
TAC   *mktac( int   op,
	      SYMB *a,
	      SYMB *b,
	      SYMB *c ) ;
TAC   *join_tac( TAC *c1,
	         TAC *c2 ) ;
void   insert( SYMB *s ) ;
int    hash( char *s ) ;
SYMB  *lookup( char *s ) ;
void   print_instr( TAC *i ) ;
char  *ts( SYMB *s,
	   char *str ) ;
void   error( char *str ) ;


void  main( int argc, char **argv )

/* The main program initialises the compiler, calls the syntax analyser and if
   this runs successfuly passes the resulting TAC on for code generation. */

{
	init_vc( argc, argv ) ;		 /* Set up things */

	(void) yyparse() ;		 /* Parse */

	if( !errors_found )
		cg( yyval.tac ) ;	 /* Generate code from TAC */

}	/* void  main( int argc, char **argv ) */


void  init_vc( int argc, char **argv )

/* Initialisation involves setting various system wide variables to sensible
   values and clearing down the symbol table. Small constants are so common we
   put them in the symbol table first and record their addresses in a table. We
   do this for the integers 0 to COUNT_MAX - 1. This will permit us efficient
   access to them throughout the compiler.

   We record the entry labels for the library routines. We happen to know from
   inspection of the library code that the entry point to PRINTN is L2 and to
   PRINTS is L4. If we rewrite the library then we may have to change these.
   This is really rather clumsy, and at the very least ought to be put in a
   single table somewhere. Note that earlier we set the first label to be used
   to L10, permitting the use of labels up to L9 for library use. */

{
	int  i ;			     /* General counter */

	symb_list   = NULL ;		     /* Freelists */
	enode_list  = NULL ;

	errors_found = FALSE ;		     /* No errors found yet */
	next_tmp     = 0 ;		     /* No temporaries used */
	next_label   = LAB_MIN ;	     /* 10 labels reserved */

	for( i = 0 ; i < HASHSIZE ; i++ )    /* Clear symbol table */
		symbtab[i] = NULL ;

	for( i = 0 ; i < CONST_MAX ; i++ )   /* Make constants */
	{
		SYMB *c = get_symb() ;	     /* Node for the constant */

		c->type      = T_INT ;
		c->VAL1      = i ;
		const_tab[i] = c ;
	}

	library[LIB_PRINTN] = mktac( TAC_LABEL, mklabel( 2 ), NULL, NULL ) ;
	library[LIB_PRINTS] = mktac( TAC_LABEL, mklabel( 4 ), NULL, NULL ) ;

        if( argc > 1 )
        {
                if( strcmp( argv[1], "-O" ) == 0 )
                {
                        optiflag = TRUE;
                        if( argc > 2 )
                                strcpy( filename, argv[2] );
                        else
                                *filename = 0;
                }
                else
                        error( "invalid argument" );
        }
        else
        {
                optiflag = FALSE;
                *filename = 0;
        }

}     /* void  init_vc( int argc, char **argv ) */


/* We now have a number of routines to set up symbol table nodes of various
   types. Memory allocation usually involves up to three routines, "mkxxx()" to
   allocate and set up the fields of a struct of type "xxx", "get_xxx()" to
   allocate space for the struct and "free_xxx()" to free up the space. */


SYMB *mkconst( int  n )

/* In "mkconst()" we check if the constant is one of the predefined ones, and
   if so use it, otherwise we create a new entry for it. Note that this wastes
   space, since we should check if we have used any constant before and return
   a pointer to an existing node if possible. However the technique of just
   predefining the first few constants (which make up the majority used) is
   a good compromise that is efficient. */

{
	if((n >= 0) && (n < CONST_MAX))
		return const_tab[n] ;
	else
	{
		SYMB *c = get_symb() ;   /* Create a new node */

		c->type = T_INT ;
		c->VAL1 = n ;
		return c ;
	}

}	/* SYMB *mkconst( int  n ) */


SYMB *mklabel( int  l )

/* Make a label node with the given value */

{
	SYMB *t = get_symb() ;

	t->type = T_LABEL ;
	t->VAL1 = l ;

	return t ;

}	/* SYMB *mklabel( int  l ) */


SYMB *mktmp( void )

/* Make a temporary name. This is just a var with name of the form Txxx. We
   force a temporary name into the lexical analyser text buffer, "yytext[]" and
   then use the lexical analyser's name allocator "mkname()". */

{
        SYMB *tmp, *hold ;

        /* yylval may hold the most recent lexeme, so save it */

        hold = yylval.symb ;

	/* Make the name with mkname */

	sprintf( yytext, "T%d", next_tmp++ ) ;   /* Set up text */
	yyleng = strlen( yytext ) ;
	mkname() ;
	yylval.symb->type = T_VAR ;

        /* Restore yylval and return the temporary name */

        tmp = yylval.symb ;
        yylval.symb = hold ;
	return tmp ;

}	/* SYMB *mktmp( void ) */


SYMB *get_symb( void )

/* Allocate space for a symbol table entry. Note the use of the freelist
   "symb_list" to hold any nodes that have been returned. If none is available
   we use "malloc()" to obtain a new node. Rather than use "malloc()" direct we
   call our own version "safe_malloc()". This guarantees to return a valid
   pointer (and never NULL). If store has run out and safe_malloc() cannot
   allocate a new structure it will print an error message and exit the
   compiler. */

{
	SYMB *t ;

	if( symb_list != NULL )
	{
		t         = symb_list ;
		symb_list = symb_list->next ;
	}
	else
		t = (SYMB *)safe_malloc( sizeof( SYMB )) ;

	return t ;

}	/* SYMB *get_symb( void ) */


void  free_symb( SYMB *s )

/* This is the sister routine to "get_symb()" and just adds the symbol node to
   the freelist for reuse. */

{
	s->next   = symb_list ;
	symb_list = s ;

}	/* void  free_symb( SYMB *s ) */


ENODE *get_enode( void )

/* Allocate for ENODE. This routine and "free_enode()" are analagous to
   "get_symb()" and "free_symb()". */

{
	if( enode_list != NULL )
	{
		ENODE *expr ;

		expr       = enode_list ;
		enode_list = expr->next ;

		return expr ;
	}
	else
		return (ENODE *)safe_malloc( sizeof( ENODE )) ;

}	/* ENODE *get_enode( void ) */


void  free_enode( ENODE *expr )

/* Return an enode for reuse */

{
	expr->next = enode_list ;
	enode_list = expr ;

}	/* void  free_enode( ENODE *expr ) */


void *safe_malloc( int  n )

/* Rather than have a test for a null pointer each time we call "malloc()" in
   the compiler we write our own safe version, "safe_malloc()".  If memory runs
   out there is no more we can do, and so the routine aborts the entire
   compilation. */

{
	void *t = malloc( n ) ;

	/* Check we got it */

	if( t == NULL )
	{
		error( "malloc() failed" ) ;
		exit( 0 ) ;
	}

	return t ;

}	/* void *safe_malloc( int  n ) */


/* A couple of routine for allocating and joining TAC lists. We need not
   maintain a freelist for TAC, since we never free a TAC quadruple once
   allocated. */


TAC *mktac( int   op,			 /* Operator */
	    SYMB *a,			 /* Result */
	    SYMB *b,			 /* Operands */
	    SYMB *c )

/* Construct a TAC quadruple with the given fields 

	a := b op c

   Note the use of #defined selectors VA, VB and VC for the TAC struct. If
   efficiency became a worry we might chose not to call "safe_malloc()" each
   time we wanted a new qaudruple, but to allocate several at once. */

{
	TAC *t = (TAC *)safe_malloc( sizeof( TAC )) ;

	t->next  = NULL ;		 /* Set these for safety */
	t->prev  = NULL ;
	t->op    = op ;
	t->VA   = a ;
	t->VB = b ;
	t->VC = c ;

	return t ;

}	/* TAC *mktac( int   op,
	    	       SYMB *a,
	    	       SYMB *b,
	    	       SYMB *c ) */


TAC *join_tac( TAC *c1,
	       TAC *c2 )

/* Join two pieces of TAC together.  Remember that in the parser we always
   refer to a TAC list by the most recently generated piece of code and so we
   follow the prev pointer to get the preceding instructions. We will end up
   with a pointer to a TAC list for the parser representing the code of "c1"
   followed by that of "c2". */

{
	TAC *t ;

	/* If either list is NULL return the other */

	if( c1 == NULL )
		return c2 ;

	if( c2 == NULL )
		return c1 ;

	/* Run down c2, until we get to the beginning and then add c1 */

	t = c2 ;

	while( t->prev != NULL )
		t = t->prev ;

	t->prev = c1 ;
	return c2 ;

}	/* TAC *join_tac( TAC *c1,
			  TAC *c2 ) */


/* These are the symbol table routines. We have a routine, "insert()", to
   insert a node in the symbol table (created by one of the "mkxxx()" routines)
   and a routine, "lookup()" to find the symbol table entry, if any, for a
   given text name. Both routines use the hashing function "hash()" described
   in chapter 5. */


void  insert( SYMB *s )

/* Insert a new symbol in the symbol table. We hash on a text first argument */

{
	int hv = hash( s->TEXT1 ) ;

	s->next = symbtab[hv] ;		 /* Insert at head */
	symbtab[hv]  = s ;

}	/* void  insert( SYMB *s ) */


int  hash( char *s )

/* Return a hashvalue from the given text. We use the bottom nybble of each
   character ORed with the top nybble of the hashvalue so far and shifted in at
   the bottom. This is then reduced mod the size of the hash table. Note the
   implicit assumption that we are on a 32 bit machine. */

{
	int  hv = 0 ;
	int  i ;

	for( i = 0 ; s[i] != EOS ; i++ )
	{
		int  v = (hv >> 28) ^ (s[i] & 0xf) ;

		hv = (hv << 4) | v ;
	}

	hv = hv & 0x7fffffff ;		 /* Ensure positive */
	return hv % HASHSIZE ;

}	/* int  hash ( char *s ) */


SYMB *lookup( char *s )

/* Lookup a name in the hashtable. Return NULL if the name is not found. */

{
	int   hv = hash( s ) ;
	SYMB *t  = symbtab[hv] ;

	while( t != NULL )		 	  /* Look for the name */
		if( strcmp( t->TEXT1, s ) == 0 )
			break ;
		else
			t = t->next ;

	return t ;			 /* NULL if not found */

}	/* SYMB lookup( char *s ) */


/* We now have a couple of routines for debugging purposes. */


void  print_instr( TAC *i )

/* "print_instr()" is used to print out a TAC instruction symbolically. We use
   it in the code generator to print each TAC instruction as a comment before
   the code generated for it. The subsidiary routine, "ts()" is used to obtain
   a suitable string representation of the TAC arguments. Note the clumsy
   programming assumption that arguments can be represented in 11 characters.
*/ 


{
	char sa[12] ;			 /* For text of TAC args */
	char sb[12] ;
	char sc[12] ;

	printf( "       ", i ) ;

	switch( i->op )
	{
	case TAC_UNDEF:

		printf( "undef\n" ) ;
		break ;

	case TAC_ADD:

		printf( "%s := %s + %s\n", ts( i->VA, sa ), ts( i->VB, sb ),
			ts( i->VC, sc )) ;
		break ;

	case TAC_SUB:

		printf( "%s := %s - %s\n", ts( i->VA, sa ), ts( i->VB, sb ),
			ts( i->VC, sc )) ;
		break ;

	case TAC_MUL:

		printf( "%s := %s * %s\n", ts( i->VA, sa ), ts( i->VB, sb ),
			ts( i->VC, sc )) ;
		break ;

	case TAC_DIV:

		printf( "%s := %s / %s\n", ts( i->VA, sa ), ts( i->VB, sb ),
			ts( i->VC, sc )) ;
		break ;

	case TAC_NEG:

		printf( "%s := - %s\n", ts( i->VA, sa ), ts( i->VB, sb )) ;
		break ;

	case TAC_COPY:

		printf( "%s := %s\n", ts( i->VA, sa ), ts( i->VB, sb )) ;
		break ;

	case TAC_GOTO:

		printf( "goto L%d\n", i->LA->VA->VAL1 ) ;
		break ;

	case TAC_IFZ:

		printf( "ifz %s goto L%d\n", ts( i->VB, sb ),
		 	i->LA->VA->VAL1 ) ;
		break ;

	case TAC_IFNZ:

		printf( "ifnz %s goto L%d\n", ts( i->VB, sb ),
			i->LA->VA->VAL1 ) ;
		break ;

	case TAC_ARG:

		printf( "arg %s\n", ts( i->VA, sa )) ;
		break ;

	case TAC_CALL:

		if( i->VA == NULL )
			printf( "call L%d\n", i->LB->VA->VAL1 ) ;
		else
			printf( "%s = call L%d\n", ts( i->VA, sa ),
				i->LB->VA->VAL1 ) ;
		break ;

	case TAC_RETURN:

		printf( "return %s\n", ts( i->VA, sa )) ;
		break ;

	case TAC_LABEL:

		printf( "label L%d\n", i->VA->VAL1 ) ;
		break ;

	case TAC_VAR:

		printf( "var %s\n", ts( i->VA, sa )) ;
		break ;

	case TAC_BEGINFUNC:

		printf( "beginfunc\n" ) ;
		break ;

	case TAC_ENDFUNC:

		printf( "endfunc\n" ) ;
		break ;

	default:

		/* Don't know what this one is */

		error( "unknown TAC opcode" ) ;
		printf( "unknown %d\n", i->op ) ;
		break ;
	}

	fflush( stdout ) ;

}	/* print_instr( i ) */


char *ts( SYMB *s,			 /* Symbol to translate */
	  char *str )			 /* String to put it in */

/* Return the string representation of the given symbol. Permissible ones are
   functions, vars, temporaries or constants */

{

	/* Check we haven't been given NULL */

	if( s == NULL )
		return "NULL" ;

	/* Identify the type */

	switch( s->type )
	{
	case T_FUNC:
	case T_VAR:

		/* Just return the name */

		return s->TEXT1 ;

	case T_TEXT:

		/* Put the address of the text */

		sprintf( str, "L%d", s->VAL2 ) ;
		return str ;

	case T_INT:

		/* Convert the number to string */

		sprintf( str, "%d", s->VAL1 ) ;
		return str ;

	default:

		/* Unknown arg type */

		error( "unknown TAC arg type" ) ;
		return "?" ;
	}

}	/* ts( SYMB *s,
	       char *str ) */


void  error( char *str )

/* This is a very simple error message routine. This is just prints a message
   to the standard error stream, and sets a flag to indicate that an error has
   occurred. If this is set at the end of parsing, then we do not carry on
   further with code generation. */

{
	fprintf( stderr, "vc: %s\n", str ) ;
	errors_found = TRUE ;

}	/* void  error( char *str ) */
//E*O*F main.c//

exit 0
